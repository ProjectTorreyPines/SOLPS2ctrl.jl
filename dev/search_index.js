var documenterSearchIndex = {"docs":
[{"location":"#SOLPS2ctrl.jl","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Pages = [\"index.md\"]\nDepth = 3","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"This repository serves as the top most workflow manager with helpful utilities to use other repositories in this project. Following steps are supported/planned in near future:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Loading SOLPS outputs into IMAS data dictionary format\nLoading equilibrium (that the SOLPS mesh was based on) into IMAS DD format\nExtrapolating results into core and far SOL region if required\nRunning synthetic diagnostics on them\nPerforming system identification (to be added)\nDesigning and tuning linear causal and model predictive controllers (to be added)","category":"page"},{"location":"#Documentation-of-other-repositories-in-this-project","page":"SOLPS2ctrl.jl","title":"Documentation of other repositories in this project","text":"","category":"section"},{"location":"#[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)","page":"SOLPS2ctrl.jl","title":"IMASggd.jl","text":"","category":"section"},{"location":"#[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)","page":"SOLPS2ctrl.jl","title":"SOLPS2imas.jl","text":"","category":"section"},{"location":"#[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)","page":"SOLPS2ctrl.jl","title":"FusionSyntheticDiagnostics.jl","text":"","category":"section"},{"location":"#Installation","page":"SOLPS2ctrl.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"using Pkg\nPkg.add(\"SOLPS2ctrl\")","category":"page"},{"location":"#Top-file-handling-functions","page":"SOLPS2ctrl.jl","title":"Top file handling functions","text":"","category":"section"},{"location":"#SOLPS2ctrl.find_files_in_allowed_folders","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.find_files_in_allowed_folders","text":"find_files_in_allowed_folders(\n    input_dirs::String...;\n    eqdsk_file::String,\n    recursive::Bool=true,\n)\n\nSearches a list of allowed folders for a set of filenames that will provide information about the SOLPS case. Returns a list of filenames with complete paths.\n\nExample:\n\nSOLPS2ctrl.find_files_in_allowed_folders(\n    \"<your samples folder>/D3D_Ma_184833_03600\";\n    eqdsk_file=\"g184833.03600\",\n)\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.geqdsk_to_imas!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.geqdsk_to_imas!","text":"geqdsk_to_imas!(\n    eqdsk_file::String,\n    dd::IMAS.dd;\n    set_time::Union{Nothing, Float64}=nothing,\n    time_index::Int=1,\n)\n\nTransfers the equilibrium reconstruction from an EFIT-style gEQDSK file into the IMAS DD structure.\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.preparation","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.preparation","text":"preparation(\n    eqdsk_file::String,\n    dirs::String...;\n    core_method::String=\"simple\",\n    filename::String=\"sd_input_data\",\n    output_format::String=\"json\",\n    eqdsk_set_time::Union{Nothing, Float64}=nothing,\n    eq_time_index::Int=1,\n    allow_boundary_flux_correction::Bool=false,\n)::IMAS.dd\n\nGathers SOLPS and EFIT files and loads them into IMAS structure. Extrapolates profiles as needed to get a complete picture.\n\n\n\n\n\n","category":"function"},{"location":"#Repairing/filling-out-partial-equilibrium-files","page":"SOLPS2ctrl.jl","title":"Repairing/filling out partial equilibrium files","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Tools for repairing/filling out partial equilibrium files.","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Some of the added fields may not be totally accurate, so it is recommended to use this tool mainly for test cases, as a utility. For a real equilibrium, problems should be fixed properly.","category":"page"},{"location":"#SOLPS2ctrl.add_rho_to_equilibrium!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.add_rho_to_equilibrium!","text":"function add_rho_to_equilibrium(dd:IMAS.dd)\n\nAdds equilibrium rho profile to the DD\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.check_rho_1d","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.check_rho_1d","text":"check_rho_1d(\n    dd::IMAS.dd;\n    time_slice::Int=1,\n    throw_on_fail::Bool=false,\n)::Bool\n\nChecks to see if rho exists and is valid in the equilibrium 1d profiles\n\n\n\n\n\n","category":"function"},{"location":"#Extrapolations","page":"SOLPS2ctrl.jl","title":"Extrapolations","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Utilities for extrapolating profiles","category":"page"},{"location":"#Core-profile-extrapolations","page":"SOLPS2ctrl.jl","title":"Core profile extrapolations","text":"","category":"section"},{"location":"#SOLPS2ctrl.extrapolate_core","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.extrapolate_core","text":"extrapolate_core(\n    edge_rho::Vector{Float64},\n    edge_quantity::Vector{Float64},\n    rho_output::Vector{Float64},\n)::Vector{Float64}\n\nFunction for assuming a core profile when given edge profile data.\n\nConcept:\n\nvalue and derivative should be continuous when joining real data\nderivative at magnetic axis is known to be 0 when making profile vs. rho, by the definition of rho\nderivative probably does something fancier between the pedestal and axis than just linear interpolation, so add an extra point in there\nthere's a joint between the steep pedestal and the shallow core that needs an extra knot to manage it properly\nafter making up a very simple gradient profile out of a few line segments, integrate it to get the profile of the quantity in question\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.fill_in_extrapolated_core_profile!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.fill_in_extrapolated_core_profile!","text":"fill_in_extrapolated_core_profile!(\n    dd::IMAS.dd,\n    quantity_name::String;\n    method::String=\"simple\",\n    eq_time_idx::Int=1,\n    eq_profiles_2d_idx::Int=1,\n    value_field::Symbol=:values,\n    grid_ggd_idx::Int=1,\n    cell_subset_idx::Int=5,\n)\n\nThis function accepts a DD that should be populated with equilibrium and edge_profiles as well as a request for a quantity to extrapolate into the core. It then maps edge_profiles data to rho, calls the function that performs the extrapolation (which is not a simple linear extrapolation but has some trickery to attempt to make a somewhat convincing profile shape), and writes the result to core_profiles. This involves a bunch of interpolations and stuff.\n\nInput arguments:\n\ndd: an IMAS data dictionary\nquantity_name: the name of a quantity in edge_profiles.profiles_2d and core_profiles.profiles_1d, such as \"electrons.density\"\nmethod: Extrapolation method.\neq_time_idx: index of the equilibrium time slice to use. For a typical SOLPS run, the SOLPS mesh will be based on the equilibrium reconstruction at a single time, so the DD associated with the SOLPS run only needs one equilibrium time slice to be loaded. However, one could combine the complete equilibrium time series with the SOLPS run and then have to specify which slice of the equilibrium corresponds to the SOLPS mesh.\neq_profiles_2d_idx: index of the profiles_2D in equilibrium time_slice.\nvalue_field: Symbolic name of the values field in quantity.\ngrid_ggd_idx: index of the grid_ggd to use. For a typical SOLPS run, the SOLPS grid is fixed, so this index defaults to 1. But in future, if a time varying grid is used, then this index will need to be specified.\ncell_subset_idx: index of the subset of cells to use for the extrapolation. The default is 5, which is the subset of all cells. If edge_profiles data is instead present for a different subset, for instance, -5, which are b2.5 cells only, then this index should be set to -5.\n\n\n\n\n\n","category":"function"},{"location":"#Edge-profiles-extrapolations","page":"SOLPS2ctrl.jl","title":"Edge profiles extrapolations","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"These functions have not been fully tested and/or supported yet.","category":"page"},{"location":"#SOLPS2ctrl.mesh_psi_spacing","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.mesh_psi_spacing","text":"mesh_psi_spacing(\n    dd::IMAS.dd;\n    eq_time_idx::Int=1,\n    eq_profiles_2d_idx::Int=1,\n    grid_ggd_idx::Int=1,\n    space_idx::Int=1,\n    avoid_guard_cell::Bool=true,\n    spacing_rule=\"mean\",\n)\n\nInspects the mesh to see how far apart faces are in psi_N. Requires that GGD and equilibrium are populated.\n\nInput Arguments:\n\ndd: a data dictionary instance with required data loaded into it\neq_time_idx: index of the equilibrium time slice to use. For a typical SOLPS run, the SOLPS mesh will be based on the equilibrium reconstruction at a single time, so the DD associated with the SOLPS run only needs one equilibrium time slice to be loaded. However, one could combine the complete equilibrium time series with the SOLPS run and then have to specify which slice of the equilibrium corresponds to the SOLPS mesh.\neq_profiles_2d_idx: index of the profiles_2D in equilibrium time_slice.\ngrid_ggd_idx: index of the grid_ggd to use. For a typical SOLPS run, the SOLPS grid is fixed, so this index defaults to 1. But in future, if a time varying grid is used, then this index will need to be specified.\nspace_idx: index of the space to use. For a typical SOLPS run, there will be only one space so this index will mostly remain at 1.\navoid_guard_cell: assume that the last cell is a guard cell so take end-2 and end-1 instead of end and end-1\nspacing_rule: \"edge\" or \"mean\" to make spacing of new cells (in psi_N) be the same as the spacing at the edge of the mesh, or the same as the average spacing\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.cached_mesh_extension!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.cached_mesh_extension!","text":"cached_mesh_extension!(\n    dd::IMAS.dd,\n    eqdsk_file::String,\n    b2fgmtry::String;\n    eq_time_idx::Int=1,\n    eq_profiles_2d_idx::Int=1,\n    grid_ggd_idx::Int=1,\n    space_idx::Int=1,\n    clear_cache::Bool=false,\n)::String\n\nAdds an extended mesh to a data dictionary, possibly from a cached result.\n\nInput Arguments:\n\ndd: The data dictionary. It will be modified in place.\neqdsk_file: the name of the EQDSK file that was used to get equilibrium data in the dd.\nb2fgmtry: the name of the SOLPS geometry file that was used to get GGD info in edge_profiles in the dd.\neq_time_idx: Index of the time slice in equilibrium\neq_profiles_2d_idx: Index of the 2D profile set in equilibrium (there is usually only one)\ngrid_ggd_idx: Index of the grid_ggd set in edge_profiles\nspace_idx: Index of the space\nclear_cache: delete any existing cache file (for use in testing)\n\n\n\n\n\n","category":"function"},{"location":"#System-identification-and-modeling","page":"SOLPS2ctrl.jl","title":"System identification and modeling","text":"","category":"section"},{"location":"#SOLPS2ctrl.offset_scale","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.offset_scale","text":"offset_scale(\n    val::Union{Float64, Vector{Float64}, Matrix{Float64}};\n    offset::Union{Float64, Vector{Float64}}=0.0,\n    factor::Union{Float64, Vector{Float64}}=1.0,\n)::typeof(val)\n\nSubtract an offset and multiply by a factor, the val to make it nominally in the range of -1 to 1 (not strictly) for easy identification of system.\n\n(val .- offset) .* factor\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.unscale_unoffset","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.unscale_unoffset","text":"unscale_unoffset(\n    offset_scaled::Union{Float64, Vector{Float64}, Matrix{Float64}};\n    offset::Union{Float64, Vector{Float64}}=0.0,\n    factor::Union{Float64, Vector{Float64}}=1.0,\n)::typeof(offset_scaled)\n\nUndo previously applied offset and scaling.\n\noffset_scaled ./ factor .+ offset\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.system_id","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.system_id","text":"system_id(\n    inp::Union{Vector{Float64}, Matrix{Float64}},\n    out::Union{Vector{Float64}, Matrix{Float64}},\n    tt::Vector{Float64},\n    order::Int;\n    input_cond::Union{Nothing, Function}=nothing,\n    inp_offset::Float64=0.0, inp_factor::Float64=1.0,\n    out_offset::Float64=0.0, out_factor::Float64=1.0,\n    input_cond_kwargs::Dict{Symbol, T}=Dict{Symbol, Any}(),\n    newpem_kwargs::Dict{Symbol, U}=Dict{Symbol, Any}(),\n    verbose::Bool=false,\n) where {T, U}\n\nPerform system identification for a set on input data inp, output data out, and time series vector tt. If there are more than one inputs or outputs, provide them as Matrix with first dimension for ports (input or output) and second dimension for time. If input_cond is provided, it is applied to offseted and scaled input before performing system identification with keywords for this function provided in input_cond_kwargs.\n\nThis function uses ControlSystemIdentification.newpem to perform the system identification. Any additional keywords for this function should be passed as dictionary in newpem_kwargs. For advanced use, it is recommended to do system identification directly with newpem instead of using this function.\n\nReturns a linear state space model of the order.\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.system_id_optimal_input_cond","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.system_id_optimal_input_cond","text":"system_id_optimal_input_cond(\n    inp::Union{Vector{Float64}, Matrix{Float64}},\n    out::Union{Vector{Float64}, Matrix{Float64}},\n    tt::Vector{Float64},\n    order::Int,\n    input_cond::Union{Nothing, Function},\n    input_cond_args_guess::Dict{Symbol, T};\n    inp_offset::Float64=0.0, inp_factor::Float64=1.0,\n    out_offset::Float64=0.0, out_factor::Float64=1.0,\n    input_cond_args_lower::Dict{Symbol, V}=Dict{Symbol, Any}(),\n    input_cond_args_upper::Dict{Symbol, W}=Dict{Symbol, Any}(),\n    newpem_kwargs::Dict{Symbol, U}=Dict{Symbol, Any}(),\n    verbose::Bool=false,\n) where {T, U, V, W}\n\nPerform system identification for a set on input data inp, output data out, and time series vector tt. If there are more than one inputs or outputs, provide them as Matrix with first dimension for ports (input or output) and second dimension for time.\n\nThe input_cond is applied to offseted and scaled input before performing system identification. The input_cond_args_guess is used as initial keyword arguments that provide the parameters of the input_cond. These arguments are then used to find the best fit while iteratively performing system_id in each step.\n\nThis function uses ControlSystemIdentification.newpem to perform the system identification. Any additional keywords for this function should be passed as dictionary in newpem_kwargs.\n\nThis function uses LsqFit.curve_fit to fit the parameters of input conditions along with performing the system identification.\n\nFor advanced use, it is recommended to do system identification directly with newpem and optimize using your favorite fitting method instead of using this function.\n\nReturns a linear state space model of the order and the keyword argument dictionary containing optimal parameters for input_cond function.\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.model_evolve","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.model_evolve","text":"model_evolve(\n    sys::Union{PredictionStateSpace, StateSpace},\n    inp::Union{Vector{Float64}, Matrix{Float64}};\n    input_cond::Union{Nothing, Function}=nothing,\n    inp_offset::Float64=0.0, inp_factor::Float64=1.0,\n    out_offset::Float64=0.0, out_factor::Float64=1.0,\n    input_cond_kwargs::Dict{Symbol, T}=Dict{Symbol, Any}(),\n)::Union{Vector{Float64}, Matrix{Float64}} where {T}\n\nEvolve a state space model sys with the input steps inp. The input is offseted and scaled with inp_offset and inp_factor and the output is unscaled and unoffseted with out_offset and out_factor. If a function is provided as inp_cond it is applied to the input after scaling and offseting along with any keywords passed for it.\n\n\n\n\n\n","category":"function"},{"location":"#Unit-conversion-utilities","page":"SOLPS2ctrl.jl","title":"Unit conversion utilities","text":"","category":"section"},{"location":"#SOLPS2ctrl.gas_unit_converter","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.gas_unit_converter","text":"gas_unit_converter(\n    value_in::Float64,\n    units_in::String,\n    units_out::String;\n    species::String=\"H\",\n    temperature::Float64=293.15,\n)\n\nConverts gas flows between different units. Uses ideal gas law to convert between Pressure * volume type flows / quantities and count / current types of units. There is a version that accepts floats in and outputs floats, and another that deals in Unitful quantities.\n\n\n\n\n\ngas_unit_converter(\n    value_in::Unitful.Quantity,\n    units_in::String,\n    units_out::String;\n    species::String=\"H\",\n    temperature=293.15 * Unitful.K,\n)\n\nConverts gas flows between different units. Uses ideal gas law to convert between Pressure * volume type flows / quantities and count / current types of units. This is the Unitful version.\n\nOutput will be unitful, but the units are not simplified automatically. You can perform operations such as\n\n(output |> Unitful.upreferred).val\nUnitful.uconvert(Unitful.whatever, output).val\n\nto handle simplification or conversion of units.\n\nAlthough this function pretends torr L s^-1 and Pa m^3 s^-1 are different, use of Unitful should cause them to behave the same way as long as you simplify or convert units at the end. This means that you can use other pressure*volume type gas units and call them torr L s^-1 and the script will deal with them up to having messy units in the output.\n\n\n\n\n\n","category":"function"}]
}
