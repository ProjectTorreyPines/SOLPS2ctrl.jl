var documenterSearchIndex = {"docs":
[{"location":"#SOLPS2ctrl.jl","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Pages = [\"index.md\"]\nDepth = 3","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"This repository serves as the top most workflow manager with helpful utilities to use other repositories in this project. Following steps are supported/planned in near future:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Loading SOLPS outputs into IMAS data dictionary format\nLoading equilibrium (that the SOLPS mesh was based on) into IMAS DD format\nExtrapolating results into core and far SOL region if required\nRunning synthetic diagnostics on them\nPerforming system identification (to be added)\nDesigning and tuning linear causal and model predictive controllers (to be added)","category":"page"},{"location":"#Documentation-of-other-repositories-in-this-project","page":"SOLPS2ctrl.jl","title":"Documentation of other repositories in this project","text":"","category":"section"},{"location":"#[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)","page":"SOLPS2ctrl.jl","title":"IMASggd.jl","text":"","category":"section"},{"location":"#[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)","page":"SOLPS2ctrl.jl","title":"SOLPS2imas.jl","text":"","category":"section"},{"location":"#[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)","page":"SOLPS2ctrl.jl","title":"FusionSyntheticDiagnostics.jl","text":"","category":"section"},{"location":"#Installation","page":"SOLPS2ctrl.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"using Pkg\nPkg.add(\"SOLPS2ctrl\")","category":"page"},{"location":"#SOLPS-related-functionality","page":"SOLPS2ctrl.jl","title":"SOLPS related functionality","text":"","category":"section"},{"location":"#Top-file-handling-functions","page":"SOLPS2ctrl.jl","title":"Top file handling functions","text":"","category":"section"},{"location":"#SOLPS2ctrl.find_files_in_allowed_folders","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.find_files_in_allowed_folders","text":"find_files_in_allowed_folders(\n    input_dirs::String...;\n    eqdsk_file::String,\n    recursive::Bool=true,\n)\n\nSearches a list of allowed folders for a set of filenames that will provide information about the SOLPS case. Returns a list of filenames with complete paths.\n\nExample:\n\nSOLPS2ctrl.find_files_in_allowed_folders(\n    \"<your samples folder>/D3D_Ma_184833_03600\";\n    eqdsk_file=\"g184833.03600\",\n)\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.geqdsk_to_imas!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.geqdsk_to_imas!","text":"geqdsk_to_imas!(\n    eqdsk_file::String,\n    dd::IMAS.dd;\n    set_time::Union{Nothing, Float64}=nothing,\n    time_index::Int=1,\n)\n\nTransfers the equilibrium reconstruction from an EFIT-style gEQDSK file into the IMAS DD structure.\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.preparation","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.preparation","text":"preparation(\n    eqdsk_file::String,\n    dirs::String...;\n    core_method::String=\"simple\",\n    filename::String=\"sd_input_data\",\n    output_format::String=\"json\",\n    eqdsk_set_time::Union{Nothing, Float64}=nothing,\n    eq_time_index::Int=1,\n    allow_boundary_flux_correction::Bool=false,\n)::IMAS.dd\n\nGathers SOLPS and EFIT files and loads them into IMAS structure. Extrapolates profiles as needed to get a complete picture.\n\n\n\n\n\n","category":"function"},{"location":"#Repairing/filling-out-partial-equilibrium-files","page":"SOLPS2ctrl.jl","title":"Repairing/filling out partial equilibrium files","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Tools for repairing/filling out partial equilibrium files.","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Some of the added fields may not be totally accurate, so it is recommended to use this tool mainly for test cases, as a utility. For a real equilibrium, problems should be fixed properly.","category":"page"},{"location":"#SOLPS2ctrl.add_rho_to_equilibrium!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.add_rho_to_equilibrium!","text":"function add_rho_to_equilibrium(dd:IMAS.dd)\n\nAdds equilibrium rho profile to the DD\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.check_rho_1d","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.check_rho_1d","text":"check_rho_1d(\n    dd::IMAS.dd;\n    time_slice::Int=1,\n    throw_on_fail::Bool=false,\n)::Bool\n\nChecks to see if rho exists and is valid in the equilibrium 1d profiles\n\n\n\n\n\n","category":"function"},{"location":"#Extrapolations","page":"SOLPS2ctrl.jl","title":"Extrapolations","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Utilities for extrapolating profiles","category":"page"},{"location":"#Core-profile-extrapolations","page":"SOLPS2ctrl.jl","title":"Core profile extrapolations","text":"","category":"section"},{"location":"#SOLPS2ctrl.extrapolate_core","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.extrapolate_core","text":"extrapolate_core(\n    edge_rho::Vector{Float64},\n    edge_quantity::Vector{Float64},\n    rho_output::Vector{Float64},\n)::Vector{Float64}\n\nFunction for assuming a core profile when given edge profile data.\n\nConcept:\n\nvalue and derivative should be continuous when joining real data\nderivative at magnetic axis is known to be 0 when making profile vs. rho, by the definition of rho\nderivative probably does something fancier between the pedestal and axis than just linear interpolation, so add an extra point in there\nthere's a joint between the steep pedestal and the shallow core that needs an extra knot to manage it properly\nafter making up a very simple gradient profile out of a few line segments, integrate it to get the profile of the quantity in question\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.fill_in_extrapolated_core_profile!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.fill_in_extrapolated_core_profile!","text":"fill_in_extrapolated_core_profile!(\n    dd::IMAS.dd,\n    quantity_name::String;\n    method::String=\"simple\",\n    eq_time_idx::Int=1,\n    eq_profiles_2d_idx::Int=1,\n    value_field::Symbol=:values,\n    grid_ggd_idx::Int=1,\n    cell_subset_idx::Int=5,\n)\n\nThis function accepts a DD that should be populated with equilibrium and edge_profiles as well as a request for a quantity to extrapolate into the core. It then maps edge_profiles data to rho, calls the function that performs the extrapolation (which is not a simple linear extrapolation but has some trickery to attempt to make a somewhat convincing profile shape), and writes the result to core_profiles. This involves a bunch of interpolations and stuff.\n\nInput arguments:\n\ndd: an IMAS data dictionary\nquantity_name: the name of a quantity in edge_profiles.profiles_2d and core_profiles.profiles_1d, such as \"electrons.density\"\nmethod: Extrapolation method.\neq_time_idx: index of the equilibrium time slice to use. For a typical SOLPS run, the SOLPS mesh will be based on the equilibrium reconstruction at a single time, so the DD associated with the SOLPS run only needs one equilibrium time slice to be loaded. However, one could combine the complete equilibrium time series with the SOLPS run and then have to specify which slice of the equilibrium corresponds to the SOLPS mesh.\neq_profiles_2d_idx: index of the profiles_2D in equilibrium time_slice.\nvalue_field: Symbolic name of the values field in quantity.\ngrid_ggd_idx: index of the grid_ggd to use. For a typical SOLPS run, the SOLPS grid is fixed, so this index defaults to 1. But in future, if a time varying grid is used, then this index will need to be specified.\ncell_subset_idx: index of the subset of cells to use for the extrapolation. The default is 5, which is the subset of all cells. If edge_profiles data is instead present for a different subset, for instance, -5, which are b2.5 cells only, then this index should be set to -5.\n\n\n\n\n\n","category":"function"},{"location":"#Edge-profiles-extrapolations","page":"SOLPS2ctrl.jl","title":"Edge profiles extrapolations","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"These functions have not been fully tested and/or supported yet.","category":"page"},{"location":"#SOLPS2ctrl.mesh_psi_spacing","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.mesh_psi_spacing","text":"mesh_psi_spacing(\n    dd::IMAS.dd;\n    eq_time_idx::Int=1,\n    eq_profiles_2d_idx::Int=1,\n    grid_ggd_idx::Int=1,\n    space_idx::Int=1,\n    avoid_guard_cell::Bool=true,\n    spacing_rule=\"mean\",\n)\n\nInspects the mesh to see how far apart faces are in psi_N. Requires that GGD and equilibrium are populated.\n\nInput Arguments:\n\ndd: a data dictionary instance with required data loaded into it\neq_time_idx: index of the equilibrium time slice to use. For a typical SOLPS run, the SOLPS mesh will be based on the equilibrium reconstruction at a single time, so the DD associated with the SOLPS run only needs one equilibrium time slice to be loaded. However, one could combine the complete equilibrium time series with the SOLPS run and then have to specify which slice of the equilibrium corresponds to the SOLPS mesh.\neq_profiles_2d_idx: index of the profiles_2D in equilibrium time_slice.\ngrid_ggd_idx: index of the grid_ggd to use. For a typical SOLPS run, the SOLPS grid is fixed, so this index defaults to 1. But in future, if a time varying grid is used, then this index will need to be specified.\nspace_idx: index of the space to use. For a typical SOLPS run, there will be only one space so this index will mostly remain at 1.\navoid_guard_cell: assume that the last cell is a guard cell so take end-2 and end-1 instead of end and end-1\nspacing_rule: \"edge\" or \"mean\" to make spacing of new cells (in psi_N) be the same as the spacing at the edge of the mesh, or the same as the average spacing\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.cached_mesh_extension!","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.cached_mesh_extension!","text":"cached_mesh_extension!(\n    dd::IMAS.dd,\n    eqdsk_file::String,\n    b2fgmtry::String;\n    eq_time_idx::Int=1,\n    eq_profiles_2d_idx::Int=1,\n    grid_ggd_idx::Int=1,\n    space_idx::Int=1,\n    clear_cache::Bool=false,\n)::String\n\nAdds an extended mesh to a data dictionary, possibly from a cached result.\n\nInput Arguments:\n\ndd: The data dictionary. It will be modified in place.\neqdsk_file: the name of the EQDSK file that was used to get equilibrium data in the dd.\nb2fgmtry: the name of the SOLPS geometry file that was used to get GGD info in edge_profiles in the dd.\neq_time_idx: Index of the time slice in equilibrium\neq_profiles_2d_idx: Index of the 2D profile set in equilibrium (there is usually only one)\ngrid_ggd_idx: Index of the grid_ggd set in edge_profiles\nspace_idx: Index of the space\nclear_cache: delete any existing cache file (for use in testing)\n\n\n\n\n\n","category":"function"},{"location":"#Unit-conversion-utilities","page":"SOLPS2ctrl.jl","title":"Unit conversion utilities","text":"","category":"section"},{"location":"#SOLPS2ctrl.gas_unit_converter","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.gas_unit_converter","text":"gas_unit_converter(\n    value_in::Float64,\n    units_in::String,\n    units_out::String;\n    species::String=\"H\",\n    temperature::Float64=293.15,\n)\n\nConverts gas flows between different units. Uses ideal gas law to convert between Pressure * volume type flows / quantities and count / current types of units. There is a version that accepts floats in and outputs floats, and another that deals in Unitful quantities.\n\n\n\n\n\ngas_unit_converter(\n    value_in::Unitful.Quantity,\n    units_in::String,\n    units_out::String;\n    species::String=\"H\",\n    temperature=293.15 * Unitful.K,\n)\n\nConverts gas flows between different units. Uses ideal gas law to convert between Pressure * volume type flows / quantities and count / current types of units. This is the Unitful version.\n\nOutput will be unitful, but the units are not simplified automatically. You can perform operations such as\n\n(output |> Unitful.upreferred).val\nUnitful.uconvert(Unitful.whatever, output).val\n\nto handle simplification or conversion of units.\n\nAlthough this function pretends torr L s^-1 and Pa m^3 s^-1 are different, use of Unitful should cause them to behave the same way as long as you simplify or convert units at the end. This means that you can use other pressure*volume type gas units and call them torr L s^-1 and the script will deal with them up to having messy units in the output.\n\n\n\n\n\n","category":"function"},{"location":"#Control-related-functionality","page":"SOLPS2ctrl.jl","title":"Control related functionality","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"This package provides a platform to perform closed loop simulations of controllers with plant models and actuator models. The key function to run these simulations is run_closed_loop_sim() described below. The common architecture for this platform is to create mutable struct for each of the actuator, plant, and controller which are subtypes of provided abstract types Actuator, Plant, and Controller and the struct itself is callable and performs the required function for a discrete time instance. See test examples to get an idea of how to use this feature.","category":"page"},{"location":"#Plant","page":"SOLPS2ctrl.jl","title":"Plant","text":"","category":"section"},{"location":"#SOLPS2ctrl.Plant","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.Plant","text":"Plant\n\nAbstract parent type for all plants. Whenever a user defined plant is created, it must be subtype of Plant.\n\nTo create a new plant with custom feautres, it must be defined as a mutable stucture which is daughter of Plant that contains all settings and state information for the plant and the instance itself should be callable to take as input a Vector{Float64} and should return an output of Vector{Float64}.\n\nmutable struct CustomPlant <: Plant\n    settings\n    state\n    # ... Anything more\nend\n\nfunction (cp::CustomPlant)(inp::Vector{Float64})::Vector{Float64}\n    # perform the plant single step forward calcualtion with inp\n    # update cp.state if required\n    return output\nend\n\nNOTE: If you need to add a linear system in your plant model, add a LinearPlant instance in the attributes of your CustomPlant and just call the LinearPlant inside your function call.\n\n\n\n\n\n","category":"type"},{"location":"#SOLPS2ctrl.LinearPlant","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.LinearPlant","text":"LinearPlant\n\nImplementation of linear system with option of scaling and offseting inputs and outputs. It stores the system in sys and state of the system in x. Constructor:\n\nLinearPlant(\n    sys::Union{PredictionStateSpace, StateSpace},\n    x=zeros(Float64, size(sys.A, 1));\n    inp_offset::Float64=0.0, inp_factor::Float64=1.0,\n    out_offset::Float64=0.0, out_factor::Float64=1.0,\n)\n\nCreates a LinearPlant instance with state space system sys and state vector x. It also defined input offsetting and scaling with  inp_offset and inp_factor, and similarly output unscaling and unoffseting with out_offset and out_factor.\n\n\n\n\n\n","category":"type"},{"location":"#SOLPS2ctrl.InputConditioning","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.InputConditioning","text":"InputConditioning\n\nAbstract parent type for creating input conditioning to plants. Whenever a user defined input coniditioning is created it must be subtype of InputConditioning.\n\nTo create a new input conditioning with custom feautres, it must be defined as a mutable stucture which is daughter of InputConditioning that contains all settings and state information for the function and the instance itself should be callable to take as input a Vector{Float64} and kwargs for any parameters used and should return an output of Vector{Float64} which is same size as the input.\n\nmutable struct CustomInpCond <: InputConditioning\n    settings\n    state\n    # ... Anything more\nend\n\nfunction (inp_cond::CustomInpCond)(inp::Vector{Float64}; kwargs...)::Vector{Float64}\n    # perform the input coniditioning single step forward calcualtion with inp\n    # Use parameters from kwargs\n    # update inp_cond.state if required\n    return output\nend\n\nNote that inp_cond must have a call signature of inp_cond(inp::Vector{Float64}; kwargs...)::Vector{Float64} to take input as a vector for multiple inputs at a particular time instance\n\n\n\n\n\n","category":"type"},{"location":"#SOLPS2ctrl.InpCondLinPlant","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.InpCondLinPlant","text":"InpCondLinPlant\n\nImplementation of a LinearPlant with an added input conditioning which could be used to make it non-linear. It stores the LinearPlant in linear_plant, the input coniditioning function in inp_cond and any keyword arguments for the inp_cond in inp_cond_kwargs. Constructor:\n\nInpCondLinPlant{T}(\n    linear_plant::LinearPlant,\n    inp_cond::InputConditioning\n    inp_cond_kwargs::Dict{Symbol, T}\n) where {T}\n\nCreates a InpCondLinPlant instance. inp_cond_kwargs can be used to have changeable parameters in the input conditioning which can be used for optimization and fiting.\n\n\n\n\n\n","category":"type"},{"location":"#System-identification-and-modeling","page":"SOLPS2ctrl.jl","title":"System identification and modeling","text":"","category":"section"},{"location":"#SOLPS2ctrl.system_id","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.system_id","text":"system_id(\n    inp::Union{Vector{Float64}, Matrix{Float64}},\n    out::Union{Vector{Float64}, Matrix{Float64}},\n    tt::Vector{Float64},\n    order::Int;\n    inp_offset::Float64=0.0, inp_factor::Float64=1.0,\n    out_offset::Float64=0.0, out_factor::Float64=1.0,\n    inp_cond::Union{Nothing, InputConditioning}=nothing,\n    inp_cond_kwargs::Dict{Symbol, T}=Dict{Symbol, Any}(),\n    newpem_kwargs::Dict{Symbol, U}=Dict{Symbol, Any}(),\n    verbose::Bool=false,\n) where {T, U}\n\nPerform system identification for a set on input data inp, output data out, and time series vector tt. If there are more than one inputs or outputs, provide them as Matrix with first dimension for ports (input or output) and second dimension for time.\n\nIf inp_cond is provided, it is applied before offsetting and scaling for performing system identification with keywords for this function provided in inp_cond_kwargs.\n\nThis function uses ControlSystemIdentification.newpem to perform the system identification. Any additional keywords for this function should be passed as dictionary in newpem_kwargs. For advanced use, it is recommended to do system identification directly with newpem instead of using this function.\n\nReturns a linear state space model of the order.\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.system_id_optimal_inp_cond","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.system_id_optimal_inp_cond","text":"system_id_optimal_inp_cond(\n    inp::Union{Vector{Float64}, Matrix{Float64}},\n    out::Union{Vector{Float64}, Matrix{Float64}},\n    tt::Vector{Float64},\n    order::Int,\n    inp_cond::InputConditioning,\n    inp_cond_args_guess::Dict{Symbol, T};\n    inp_offset::Float64=0.0, inp_factor::Float64=1.0,\n    out_offset::Float64=0.0, out_factor::Float64=1.0,\n    inp_cond_args_lower::Dict{Symbol, V}=Dict{Symbol, Any}(),\n    inp_cond_args_upper::Dict{Symbol, W}=Dict{Symbol, Any}(),\n    newpem_kwargs::Dict{Symbol, U}=Dict{Symbol, Any}(),\n    curve_fit_kwargs::Dict{Symbol, X}=Dict{Symbol, Any}(),\n    verbose::Bool=false,\n) where {T, U, V, W}\n\nPerform system identification for a set on input data inp, output data out, and time series vector tt. If there are more than one inputs or outputs, provide them as Matrix with first dimension for ports (input or output) and second dimension for time.\n\nThe inp_cond is applied before offsetting and scaling for performing system identification. The inp_cond_args_guess is used as initial keyword arguments that provide the parameters of the inp_cond. These arguments are then used to find the best fit while iteratively performing system_id in each step.\n\nThis function uses ControlSystemIdentification.newpem to perform the system identification. Any additional keywords for this function should be passed as dictionary in newpem_kwargs.\n\nThis function uses LsqFit.curve_fit to fit the parameters of input conditions along with performing the system identification.\n\nFor advanced use, it is recommended to do system identification directly with newpem and optimize using your favorite fitting method instead of using this function.\n\nReturns a NonLinInpLinearPlant that has stored best fit parameters for the input non-linearity and a best fit linear model.\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.model_evolve","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.model_evolve","text":"model_evolve(\n    plant::Plant,\n    inp::Union{Vector{Float64}, Matrix{Float64}};\n    x0::Union{Nothing, Vector{Float64}}=nothing,\n    initialize_x::Bool=false,\n)\n\nEvolve a plant model through a time series of inputs. If inp is a Matrix, the first dimension will hold different inputs and second dimension will be along time. If inp is a vector, it would be assumed that the model has a single input. If the model also happens to have a single output and inp is a vector, the returned outputs will be a vector as well. If x0 is not provided, the stored state vector of the plant model will be used for initialization. If initialize_x is true, then the state vector of the plant model would be initialized to match first input value so that no sudden jumps happen.\n\n\n\n\n\n","category":"function"},{"location":"#Actuators","page":"SOLPS2ctrl.jl","title":"Actuators","text":"","category":"section"},{"location":"#SOLPS2ctrl.Actuator","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.Actuator","text":"Actuator\n\nAbstract parent type for all actuators. Whenever a user defined actuator is created, it must be subtype of Actuator.\n\nTo create a new actuator with custom function, it must be defined as a mutable stucture which is daughter of Actuator that contains all settings and state information for the actuator and the instance itself should be callable to take as input a Vector{Float64} and should return an output of Vector{Float64}.\n\nmutable struct CustomActuator <: Actuator\n    settings\n    state\n    # ... Anything more\nend\n\nfunction (ca::CustomActuator)(inp::Vector{Float64})::Vector{Float64}\n    # perform the actuation calcualtions with inp\n    # update ca.state if required\n    return output\nend\n\nNOTE: If you need to add a delay in the actuator, add a DelayedActuator instance in the attributes of your CustomActuator and just call the DelayedActuator inside your function call.\n\n\n\n\n\n","category":"type"},{"location":"#SOLPS2ctrl.DelayedActuator","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.DelayedActuator","text":"DelayedActuator{U}\n\nImplementation of delayed actuation. It stores delay::Int for number of time steps of delay and buffer::Queue{U} which stores the delayed actuations in a queue. Constructor:\n\nDelayedActuator(\n    delay::Int;\n    default_output::T=[0.0],\n) where {T}\n\nCreates a DelayedActuator{T} instance with delay and initializes the buffer pre-filled upto brim with the default_output.\n\n\n\n\n\n","category":"type"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"For example:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"using SOLPS2ctrl: DelayedActuator\n# Actuator with delay of 3 steps\ndact = DelayedActuator(3; default_output=[0.0, 0.0])\ninp_series = [ones(2) * i * 0.1 for i in 1:6]\nfor (i, inp) in enumerate(inp_series)\n    println(\"Calling $(i)th time, return value is $(dact(inp))\")\nend","category":"page"},{"location":"#Controllers","page":"SOLPS2ctrl.jl","title":"Controllers","text":"","category":"section"},{"location":"#SOLPS2ctrl.Controller","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.Controller","text":"Controller\n\nAbstract parent type for all controllers. Whenever a user defined controller is created it must be a subtype of Controller.\n\nTo create a new controller algorithm, it should be defined as a mutable structure that is a daughter of Controller and should contain all settings and state information to be stored. It must be a callable structure that can use any of the following keyword arguments:\n\nii::Int: Iteration index\ntarget::Matrix{Float64}: Target waveform (No. of signals x Time steps)\nplant_inp::Matrix{Float64}: Inputs to plant (No. of inputs x Time steps)\nplant_out::Matrix{Float64}: Outputs from plant (No. of outputs x Time steps)\nact::Actuator: Actuator model in the loop\ninp_feedforward::Matrix{Float64}: Feedforward input to the plant (No. of inputs x Time steps)\nkwargs..: Required to ignore unused keyword arguments\n\n\n\n\n\n","category":"type"},{"location":"#Linear-Controller","page":"SOLPS2ctrl.jl","title":"Linear Controller","text":"","category":"section"},{"location":"#SOLPS2ctrl.LinearController","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.LinearController","text":"LinearController\n\nImplementation for using any linear controller. It stores ctrl_ss::StateSpace{TE} where {TE <: Discrete} for storing any linear controller as a discrete state space model using ControlSystemsBase.ss. It also stores the state vector for the state space model as ctrl_x0::Vector{Float64}. It's call signature is:\n\n(lc::LinearController)(;\n    ii::Int,\n    target::Matrix{Float64},\n    plant_out::Matrix{Float64},\n    kwargs...,\n)::Vector{Float64}\n\nCalcualtes error as target[:, ii] .- plant_out[:, ii] and runs it through lsim_step().\n\n\n\n\n\n","category":"type"},{"location":"#Predicted-Variable-Linear-Controller","page":"SOLPS2ctrl.jl","title":"Predicted Variable Linear Controller","text":"","category":"section"},{"location":"#SOLPS2ctrl.PVLC","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.PVLC","text":"PVLC\n\n# Constructor\nPVLC(\n    ctrl_ss::StateSpace{TE},\n    ctrl_x0::Vector{Float64},\n    plant::LinearPlant,\n    h::Int,\n) where {TE <: Discrete}\n\nImplementation of Predicted Variable Linear Controller (PVLC). It stores ctrl_ss::StateSpace{TE} where {TE <: Discrete} for storing any linear controller as a discrete state space model using ControlSystemsBase.ss. It also stores the state vector for the state space model as ctrl_x0::Vector{Float64}. Additionally, it stores the plant, the number of steps of history h used for state tracking and state prediction matrices Y2x and U2x from state_prediction_matrices().\n\nThis controller has a call signature:\n\n(pvlc::PVLC)(;\n    ii::Int,\n    target::Matrix{Float64},\n    plant_inp::Matrix{Float64},\n    plant_out::Matrix{Float64},\n    act::Actuator,\n    kwargs...,\n)::Vector{Float64}\n\nTracks the state vector of the plant using h steps of history from plant_inp and plant_out and uses it to calculate future output of the plant. It compares it with a future target value and applies the linear controller ctrl_ss there.\n\n\n\n\n\n","category":"type"},{"location":"#SOLPS2ctrl.state_prediction_matrices","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.state_prediction_matrices","text":"state_prediction_matrices(\n    sys::Union{PredictionStateSpace, StateSpace},\n    h::Int=size(sys.A, 1),\n)\n\nCalculate state prediction matrices for a linear system sys given h steps of input and output history. This function returns two matrices, Y2x and U2x that can be used to calculate least square fitted estimate of the current state vector of the system. Y2x has size: (State size of sys) x (No. of outputs times h) U2x has size: (State size of sys) x (No. of inputs times h) The estimated state vector is obtained by: Y2x * Y + U2x * U where Y is all the h outputs of system stacked into a single vector. and U is all the h inputs to the system stacked into a single vector.\n\n\n\n\n\n","category":"function"},{"location":"#State-Prediction-Matrix-Algebra","page":"SOLPS2ctrl.jl","title":"State Prediction Matrix Algebra","text":"","category":"section"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"At step k:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"beginsplit\ny_k = C x_k + D u_k\nx_k = A x_k-1 + B u_k-1\nx_k+1 = A x_k + B u_k\nendsplit","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Therefore to h steps in history:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"For all output estimates:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"beginsplit\ny_k  = C x_k + D u_k \n     = C (A x_k-1 + B u_k-1) + D u_k \n     = C (A (A x_k-2 + B u_k-2) + B u_k-1) + D u_k \n     =  \n     = C A^h-1 x_k-(h-1) + C A^h-2 B u_k-(h-1) + C A^h-3 B u_k-(h-2) +  + CAB u_k-2 + CB u_k-1 + D u_k \nendsplit","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"beginsplit\ny_k         = C A^h-1 x_k-(h-1) + C A^h-2 B u_k-(h-1) + C A^h-3 B u_k-(h-2) +  + CAB u_k-2 + CB u_k-1 + D u_k \ny_k-1     = C A^h-2 x_k-(h-1) + C A^h-3 B u_k-(h-1) + C A^h-4 B u_k-(h-2) +  + CAB u_k-3 + CB u_k-2 + D u_k-1 \n\n         =  \ny_k-i     = C A^h-1-i x_k-(h-1) + C A^h-2-i B u_k-(h-1) + C A^h-3-i B u_k-(h-2) +  + CB u_k-i-1 + D u_k-i \n         =  \ny_k-(h-3) = C A^2 x_k-(h-1) + CAB u_k-(h-1)+ CB u_k-(h-2) + D u_k-(h-3) \ny_k-(h-2) = C A x_k-(h-1) + CB u_k-(h-1) + D u_k-(h-2) \ny_k-(h-1) = C x_k-(h-1) + D u_k-(h-1)\nendsplit","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"For predicted next state:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"beginsplit\nx_k+1  = A x_k + B u_k \n         = A (A x_k-1 + B u_k-1) + B u_k \n         = A (A (A x_k-2 + B u_k-2)  + B u_k-1) + B u_k \n         =  \n         = A^h x_k-(h-1) + A^h-1 B u_k-(h-1) + A^h-2 B u_k-(h-2) +  + A^2 B u_k-2 + A B u_k-1 + B u_k \nendsplit","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"In terms of mega-matrices, define mega-vectors of inputs and outputs:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"vecY  = beginbmatrix\n                y_k-(h-1) \n                y_k-(h-2) \n                 \n                y_k-1 \n                y_k\n              endbmatrix","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Note that for multiple outputs, each output vector will be stacked vertically to create a single column.","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"vecU  = beginbmatrix\n                u_k-(h-1) \n                u_k-(h-2) \n                 \n                u_k-1 \n                u_k\n              endbmatrix","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Note that for multiple inputs, each input vector will be stacked vertically to create a single column.","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Then, from x_k-(h-1) and vecU, we get vecY and predicted state x_k+1:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"vecY = mathcalL x_k-(h-1) + mathcalM vecU","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"x_k+1 = mathcalN x_k-(h-1) + mathcalO vecU","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Where the mega-matrices mathcalL, mathcalM, mathcalN, mathcalO are:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalL is a matrix with (h x no. of outputs) rows and state-space order columns:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalL = beginbmatrix\n                  C \n                  CA \n                  CA^2 \n                   \n                  CA^h-2 \n                  CA^h-1\n               endbmatrix","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalM is a matrix with (h x no. of outputs) rows and (h x no. of inputs) columns:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalM = beginbmatrix\n                  D            0            0              0      0      0    0        \n                  CB           D            0              0      0      0    0        \n                  CAB          CB           D              0      0      0    0        \n                                                               \n                  C A^h-4 B  C A^h-5 B  C A^h-6 B    CAB    CB     D    0    0   \n                  C A^h-3 B  C A^h-4 B  C A^h-5 B    CA^2B  CAB    CB   D    0   \n                  C A^h-2 B  C A^h-3 B  C A^h-4 B    CA^3B  CA^2B  CAB  CB   D   \n                 endbmatrix","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalN is a square matrix with state-space order columns and rows:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalN = A^h","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalO is a matrix with state-space order rows and (h x no. of inputs) columns:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"mathcalO = beginbmatrix A^h-1 B  A^h-2 B  A^h-3 B    A^2 B  AB  B endbmatrix","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"Then, future state can be predicted by:","category":"page"},{"location":"","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.jl","text":"x_k+1 = mathcalN mathcalL^-1 (vecY - mathcalM vecU) + mathcalO vecU","category":"page"},{"location":"#Model-Predictive-Controller","page":"SOLPS2ctrl.jl","title":"Model Predictive Controller","text":"","category":"section"},{"location":"#SOLPS2ctrl.MPC","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.MPC","text":"MPC\n\n# Constructor\nMPC(\n    plant::Plant,\n    h::Int,\n    act::Actuator,               # Actuator model without delay\n    horizon::Int,                # Number of steps in future after latency\n    nopt::Int,                   # Number of optimization points in horizon window\n    opt_every::Int;              # Run cost optimization every opt_every steps\n    ctrl_out_bounds::Tuple{Vector{Float64}, Vector{Float64}}=(\n        Array{Float64}(undef, 0),\n        Array{Float64}(undef, 0),\n    ),\n    guess::Union{Symbol, Vector{Float64}}=:zeros,\n    curve_fit_kwargs::Dict{Symbol, T}=Dict{Symbol, Any}(),\n)\n\nImplementation of simple leaqt square optimized Model Predictive Controller (MPC). It stores the plant, the number of steps of history h used for state tracking and state prediction matrices Y2x and U2x from state_prediction_matrices(). It stores a current deep copy of actuator instance  in act to try it during optimization and it stores setting for least square optimization. It also stores a future_evolve that is created based on plant, act, and optimization setting and is the model function that is used for optimization later. This controller stores a buffer for control outputs, ctrl_out_buffer so that it can be called less often and it can reuse it's previous optimization results.\n\nThis contructor takes in minimum required information to create a self-consistent MPC instance. It sets the other dependent quantities in MPC such as Y2x, U2x, min_delay, and create a future_evolve function and initializes the ctrl_out_buffer. act needs to be a deepcopy of the actuator instance. horizon is the number of steps after the min_delay among all acturators for which the optimization is carried out. nopt is the number of optimization points taken along the horizon which are lineary distributed. The gaps between this optimzation points are interpolated linearly in the output. opt_every defines the frequency of optimization, i.e. at every opt_every call of this controller, the optimization is carried out. This avoids unnecessary over-calculations and thus results in a faster controller. ctrl_out_bounds is a tuple of lower bounds and upper bounds for the control output. guess is used to create the initial guess during least square optimization. If :last, it would use the last controller output as initial setting. If it is a Vector, each initialization starts with this Vector. In all other cases, initial guess is zeros. curve_fit_kwargs can be used to provide keyword arguments that go to curve_fit.\n\nThis controller has a call signature:\n\nfunction (mpc::MPC)(;\n    ii::Int,\n    target::Matrix{Float64},\n    plant_inp::Matrix{Float64},\n    plant_out::Matrix{Float64},\n    act::Actuator,\n    inp_feedforward::Matrix{Float64}=zeros(\n        Float64,\n        (size(get_sys(plant).B, 2), length(target)),\n    ),\n    kwargs...,\n)::Vector{Float64} where {T}\n\nTracks the state vector of the plant using h steps of history from plant_inp and plant_out and uses it along with act to run an optimization to match target in future after the minimum delay from all the actuators. This function uses curve_fit() for the non-linear least squares fitting which uses Levenberg-Marquardt algorithm. This function performs the optimization every opt_every call and uses the stored control output in ctrl_out_buffer meanwhile.\n\n\n\n\n\n","category":"type"},{"location":"#Closed-loop-simulations","page":"SOLPS2ctrl.jl","title":"Closed loop simulations","text":"","category":"section"},{"location":"#SOLPS2ctrl.run_closed_loop_sim","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.run_closed_loop_sim","text":"run_closed_loop_sim(\n    plant::Union{PredictionStateSpace{TE}, StateSpace{TE}},\n    act::Actuator,\n    ctrl::Controller,\n    target::Matrix{Float64};\n    inp_feedforward::Matrix{Float64}=zeros(\n        Float64,\n        (size(get_sys(plant).B, 2), size(target, 2)),\n    ),\n    ctrl_start_ind::Int=1,\n    noise_plant_inp::Matrix{Float64}=zeros(\n        Float64,\n        (size(get_sys(plant).B, 2), size(target, 2)),\n    ),\n    noise_plant_out::Matrix{Float64}=zeros(\n        Float64,\n        (size(get_sys(plant).C, 1), size(target, 2)),\n    ),\n    noise_ctrl_out::Matrix{Float64}=zeros(\n        Float64,\n        (size(get_sys(plant).B, 2), size(target, 2)),\n    ),\n) where {T, TE <: Discrete}\n\nGeneric function to run closed loop simulations with provided plant, actuator act, controller ctrl, and target waveform target. The length of simulation is determined by provided target. Keyword arguments are possible for providing adjustments to inputs and outputs of the plant model as explained in model_evolve(). Additionally, ctrl_start_ind can be provided to start control loop at an arbitrary point in the loop. noise_plant_inp, noise_plant_out, and noise_ctrl_out allow addition of predefined noise waveforms at the input of plant, output of plant, and the output of controller respectively.\n\n\n\n\n\n","category":"function"},{"location":"#Control-related-utilities","page":"SOLPS2ctrl.jl","title":"Control related utilities","text":"","category":"section"},{"location":"#SOLPS2ctrl.lsim_step","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.lsim_step","text":"lsim_step(\n    sys::Union{PredictionStateSpace, StateSpace}, u::Vector{Float64};\n    x0::Vector{Float64}=zeros(size(sys.A, 1)),\n)::Tuple{Vector{Float64}, Vector{Float64}}\n\nSingle step version of ControlSystemsBase.lsim\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.offset_scale","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.offset_scale","text":"offset_scale(\n    val::Union{Float64, Vector{Float64}, Matrix{Float64}};\n    offset::Union{Float64, Vector{Float64}}=0.0,\n    factor::Union{Float64, Vector{Float64}}=1.0,\n)::typeof(val)\n\nSubtract an offset and multiply by a factor, the val to make it nominally in the range of -1 to 1 (not strictly) for easy identification of system.\n\n(val .- offset) .* factor\n\n\n\n\n\n","category":"function"},{"location":"#SOLPS2ctrl.unscale_unoffset","page":"SOLPS2ctrl.jl","title":"SOLPS2ctrl.unscale_unoffset","text":"unscale_unoffset(\n    offset_scaled::Union{Float64, Vector{Float64}, Matrix{Float64}};\n    offset::Union{Float64, Vector{Float64}}=0.0,\n    factor::Union{Float64, Vector{Float64}}=1.0,\n)::typeof(offset_scaled)\n\nUndo previously applied offset and scaling.\n\noffset_scaled ./ factor .+ offset\n\n\n\n\n\n","category":"function"}]
}
