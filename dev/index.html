<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SOLPS2ctrl.jl · SOLPS2ctrl</title><meta name="title" content="SOLPS2ctrl.jl · SOLPS2ctrl"/><meta property="og:title" content="SOLPS2ctrl.jl · SOLPS2ctrl"/><meta property="twitter:title" content="SOLPS2ctrl.jl · SOLPS2ctrl"/><meta name="description" content="Documentation for SOLPS2ctrl."/><meta property="og:description" content="Documentation for SOLPS2ctrl."/><meta property="twitter:description" content="Documentation for SOLPS2ctrl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SOLPS2ctrl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SOLPS2ctrl.jl</a><ul class="internal"><li><a class="tocitem" href="#Documentation-of-other-repositories-in-this-project"><span>Documentation of other repositories in this project</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#SOLPS-related-functionality"><span>SOLPS related functionality</span></a></li><li><a class="tocitem" href="#Control-related-functionality"><span>Control related functionality</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SOLPS2ctrl.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SOLPS2ctrl.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SOLPS2ctrl.jl"><a class="docs-heading-anchor" href="#SOLPS2ctrl.jl">SOLPS2ctrl.jl</a><a id="SOLPS2ctrl.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SOLPS2ctrl.jl" title="Permalink"></a></h1><ul><li><a href="#SOLPS2ctrl.jl">SOLPS2ctrl.jl</a></li><li class="no-marker"><ul><li><a href="#Documentation-of-other-repositories-in-this-project">Documentation of other repositories in this project</a></li><li class="no-marker"><ul><li><a href="#[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)">IMASggd.jl</a></li><li><a href="#[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)">SOLPS2imas.jl</a></li><li><a href="#[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)">FusionSyntheticDiagnostics.jl</a></li></ul></li><li><a href="#Installation">Installation</a></li><li><a href="#SOLPS-related-functionality">SOLPS related functionality</a></li><li class="no-marker"><ul><li><a href="#Top-file-handling-functions">Top file handling functions</a></li><li><a href="#Repairing/filling-out-partial-equilibrium-files">Repairing/filling out partial equilibrium files</a></li><li><a href="#Extrapolations">Extrapolations</a></li><li><a href="#Unit-conversion-utilities">Unit conversion utilities</a></li></ul></li><li><a href="#Control-related-functionality">Control related functionality</a></li><li class="no-marker"><ul><li><a href="#Plant">Plant</a></li><li><a href="#System-identification-and-modeling">System identification and modeling</a></li><li><a href="#Actuators">Actuators</a></li><li><a href="#Controllers">Controllers</a></li><li><a href="#Closed-loop-simulations">Closed loop simulations</a></li><li><a href="#Control-related-utilities">Control related utilities</a></li></ul></li></ul></li></ul><p>This repository serves as the top most workflow manager with helpful utilities to use other repositories in this project. Following steps are supported/planned in near future:</p><ul><li>Loading SOLPS outputs into IMAS data dictionary format</li><li>Loading equilibrium (that the SOLPS mesh was based on) into IMAS DD format</li><li>Extrapolating results into core and far SOL region if required</li><li>Running synthetic diagnostics on them</li><li>Performing system identification (to be added)</li><li>Designing and tuning linear causal and model predictive controllers (to be added)</li></ul><h2 id="Documentation-of-other-repositories-in-this-project"><a class="docs-heading-anchor" href="#Documentation-of-other-repositories-in-this-project">Documentation of other repositories in this project</a><a id="Documentation-of-other-repositories-in-this-project-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-of-other-repositories-in-this-project" title="Permalink"></a></h2><h3 id="[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)"><a class="docs-heading-anchor" href="#[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)"><a href="https://projecttorreypines.github.io/IMASggd.jl/stable">IMASggd.jl</a></a><a id="[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)-1"></a><a class="docs-heading-anchor-permalink" href="#[IMASggd.jl](https://projecttorreypines.github.io/IMASggd.jl/stable)" title="Permalink"></a></h3><h3 id="[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)"><a class="docs-heading-anchor" href="#[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)"><a href="https://projecttorreypines.github.io/SOLPS2imas.jl/stable">SOLPS2imas.jl</a></a><a id="[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)-1"></a><a class="docs-heading-anchor-permalink" href="#[SOLPS2imas.jl](https://projecttorreypines.github.io/SOLPS2imas.jl/stable)" title="Permalink"></a></h3><h3 id="[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)"><a class="docs-heading-anchor" href="#[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)"><a href="https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable">FusionSyntheticDiagnostics.jl</a></a><a id="[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)-1"></a><a class="docs-heading-anchor-permalink" href="#[FusionSyntheticDiagnostics.jl](https://projecttorreypines.github.io/FusionSyntheticDiagnostics.jl/stable)" title="Permalink"></a></h3><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="nohighlight hljs">using Pkg
Pkg.add(&quot;SOLPS2ctrl&quot;)</code></pre><h2 id="SOLPS-related-functionality"><a class="docs-heading-anchor" href="#SOLPS-related-functionality">SOLPS related functionality</a><a id="SOLPS-related-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#SOLPS-related-functionality" title="Permalink"></a></h2><h3 id="Top-file-handling-functions"><a class="docs-heading-anchor" href="#Top-file-handling-functions">Top file handling functions</a><a id="Top-file-handling-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Top-file-handling-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.find_files_in_allowed_folders" href="#SOLPS2ctrl.find_files_in_allowed_folders"><code>SOLPS2ctrl.find_files_in_allowed_folders</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_files_in_allowed_folders(
    input_dirs::String...;
    eqdsk_file::String,
    recursive::Bool=true,
)</code></pre><p>Searches a list of allowed folders for a set of filenames that will provide information about the SOLPS case. Returns a list of filenames with complete paths.</p><p>Example:</p><pre><code class="language-julia hljs">SOLPS2ctrl.find_files_in_allowed_folders(
    &quot;&lt;your samples folder&gt;/D3D_Ma_184833_03600&quot;;
    eqdsk_file=&quot;g184833.03600&quot;,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/SOLPS2ctrl.jl#L19-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.geqdsk_to_imas!" href="#SOLPS2ctrl.geqdsk_to_imas!"><code>SOLPS2ctrl.geqdsk_to_imas!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geqdsk_to_imas!(
    eqdsk_file::String,
    dd::IMAS.dd;
    set_time::Union{Nothing, Float64}=nothing,
    time_index::Int=1,
)</code></pre><p>Transfers the equilibrium reconstruction from an EFIT-style gEQDSK file into the IMAS DD structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/SOLPS2ctrl.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.preparation" href="#SOLPS2ctrl.preparation"><code>SOLPS2ctrl.preparation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preparation(
    eqdsk_file::String,
    dirs::String...;
    core_method::String=&quot;simple&quot;,
    filename::String=&quot;sd_input_data&quot;,
    output_format::String=&quot;json&quot;,
    eqdsk_set_time::Union{Nothing, Float64}=nothing,
    eq_time_index::Int=1,
    allow_boundary_flux_correction::Bool=false,
)::IMAS.dd</code></pre><p>Gathers SOLPS and EFIT files and loads them into IMAS structure. Extrapolates profiles as needed to get a complete picture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/SOLPS2ctrl.jl#L247-L261">source</a></section></article><h3 id="Repairing/filling-out-partial-equilibrium-files"><a class="docs-heading-anchor" href="#Repairing/filling-out-partial-equilibrium-files">Repairing/filling out partial equilibrium files</a><a id="Repairing/filling-out-partial-equilibrium-files-1"></a><a class="docs-heading-anchor-permalink" href="#Repairing/filling-out-partial-equilibrium-files" title="Permalink"></a></h3><p>Tools for repairing/filling out partial equilibrium files.</p><p>Some of the added fields may not be totally accurate, so it is recommended to use this tool mainly for test cases, as a utility. For a real equilibrium, problems should be fixed properly.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.add_rho_to_equilibrium!" href="#SOLPS2ctrl.add_rho_to_equilibrium!"><code>SOLPS2ctrl.add_rho_to_equilibrium!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function add_rho_to_equilibrium(dd:IMAS.dd)</code></pre><p>Adds equilibrium rho profile to the DD</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/repair_eq.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.check_rho_1d" href="#SOLPS2ctrl.check_rho_1d"><code>SOLPS2ctrl.check_rho_1d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_rho_1d(
    dd::IMAS.dd;
    time_slice::Int=1,
    throw_on_fail::Bool=false,
)::Bool</code></pre><p>Checks to see if rho exists and is valid in the equilibrium 1d profiles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/repair_eq.jl#L15-L23">source</a></section></article><h3 id="Extrapolations"><a class="docs-heading-anchor" href="#Extrapolations">Extrapolations</a><a id="Extrapolations-1"></a><a class="docs-heading-anchor-permalink" href="#Extrapolations" title="Permalink"></a></h3><p>Utilities for extrapolating profiles</p><h4 id="Core-profile-extrapolations"><a class="docs-heading-anchor" href="#Core-profile-extrapolations">Core profile extrapolations</a><a id="Core-profile-extrapolations-1"></a><a class="docs-heading-anchor-permalink" href="#Core-profile-extrapolations" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.extrapolate_core" href="#SOLPS2ctrl.extrapolate_core"><code>SOLPS2ctrl.extrapolate_core</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrapolate_core(
    edge_rho::Vector{Float64},
    edge_quantity::Vector{Float64},
    rho_output::Vector{Float64},
)::Vector{Float64}</code></pre><p>Function for assuming a core profile when given edge profile data.</p><p>Concept:</p><ol><li>value and derivative should be continuous when joining real data</li><li>derivative at magnetic axis is known to be 0 when making profile vs. rho, by the definition of rho</li><li>derivative probably does something fancier between the pedestal and axis than just linear interpolation, so add an extra point in there</li><li>there&#39;s a joint between the steep pedestal and the shallow core that needs an extra knot to manage it properly</li><li>after making up a very simple gradient profile out of a few line segments, integrate it to get the profile of the quantity in question</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/supersize_profile.jl#L42-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.fill_in_extrapolated_core_profile!" href="#SOLPS2ctrl.fill_in_extrapolated_core_profile!"><code>SOLPS2ctrl.fill_in_extrapolated_core_profile!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_in_extrapolated_core_profile!(
    dd::IMAS.dd,
    quantity_name::String;
    method::String=&quot;simple&quot;,
    eq_time_idx::Int=1,
    eq_profiles_2d_idx::Int=1,
    value_field::Symbol=:values,
    grid_ggd_idx::Int=1,
    cell_subset_idx::Int=5,
)</code></pre><p>This function accepts a DD that should be populated with <code>equilibrium</code> and <code>edge_profiles</code> as well as a request for a quantity to extrapolate into the core. It then maps <code>edge_profiles</code> data to rho, calls the function that performs the extrapolation (which is not a simple linear extrapolation but has some trickery to attempt to make a somewhat convincing profile shape), and writes the result to core_profiles. This involves a bunch of interpolations and stuff.</p><p>Input arguments:</p><ul><li><code>dd</code>: an IMAS data dictionary</li><li><code>quantity_name</code>: the name of a quantity in <code>edge_profiles.profiles_2d</code> and <code>core_profiles.profiles_1d</code>, such as &quot;electrons.density&quot;</li><li><code>method</code>: Extrapolation method.</li><li><code>eq_time_id</code>x: index of the equilibrium time slice to use. For a typical SOLPS run, the SOLPS mesh will be based on the equilibrium reconstruction at a single time, so the DD associated with the SOLPS run only needs one equilibrium time slice to be loaded. However, one could combine the complete equilibrium time series with the SOLPS run and then have to specify which slice of the equilibrium corresponds to the SOLPS mesh.</li><li><code>eq_profiles_2d_idx</code>: index of the <code>profiles_2D</code> in equilibrium <code>time_slice</code>.</li><li><code>value_field</code>: Symbolic name of the values field in quantity.</li><li><code>grid_ggd_idx</code>: index of the <code>grid_ggd</code> to use. For a typical SOLPS run, the SOLPS grid is fixed, so this index defaults to 1. But in future, if a time varying grid is used, then this index will need to be specified.</li><li><code>cell_subset_idx</code>: index of the subset of cells to use for the extrapolation. The default is 5, which is the subset of all cells. If <code>edge_profiles</code> data is instead present for a different subset, for instance, -5, which are b2.5 cells only, then this index should be set to -5.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/supersize_profile.jl#L105-L145">source</a></section></article><h4 id="Edge-profiles-extrapolations"><a class="docs-heading-anchor" href="#Edge-profiles-extrapolations">Edge profiles extrapolations</a><a id="Edge-profiles-extrapolations-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-profiles-extrapolations" title="Permalink"></a></h4><p>These functions have not been fully tested and/or supported yet.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.mesh_psi_spacing" href="#SOLPS2ctrl.mesh_psi_spacing"><code>SOLPS2ctrl.mesh_psi_spacing</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh_psi_spacing(
    dd::IMAS.dd;
    eq_time_idx::Int=1,
    eq_profiles_2d_idx::Int=1,
    grid_ggd_idx::Int=1,
    space_idx::Int=1,
    avoid_guard_cell::Bool=true,
    spacing_rule=&quot;mean&quot;,
)</code></pre><p>Inspects the mesh to see how far apart faces are in psi_N. Requires that GGD and equilibrium are populated.</p><p>Input Arguments:</p><ul><li><code>dd</code>: a data dictionary instance with required data loaded into it</li><li><code>eq_time_idx</code>: index of the equilibrium time slice to use. For a typical SOLPS run, the SOLPS mesh will be based on the equilibrium reconstruction at a single time, so the DD associated with the SOLPS run only needs one equilibrium time slice to be loaded. However, one could combine the complete equilibrium time series with the SOLPS run and then have to specify which slice of the equilibrium corresponds to the SOLPS mesh.</li><li><code>eq_profiles_2d_id</code>x: index of the <code>profiles_2D</code> in equilibrium <code>time_slice</code>.</li><li><code>grid_ggd_idx</code>: index of the <code>grid_ggd</code> to use. For a typical SOLPS run, the SOLPS grid is fixed, so this index defaults to 1. But in future, if a time varying grid is used, then this index will need to be specified.</li><li><code>space_idx</code>: index of the space to use. For a typical SOLPS run, there will be only one space so this index will mostly remain at 1.</li><li><code>avoid_guard_cell</code>: assume that the last cell is a guard cell so take <code>end-2</code> and <code>end-1</code> instead of <code>end</code> and <code>end-1</code></li><li><code>spacing_rule</code>: &quot;edge&quot; or &quot;mean&quot; to make spacing of new cells (in <code>psi_N</code>) be the same as the spacing at the edge of the mesh, or the same as the average spacing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/supersize_profile.jl#L331-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.cached_mesh_extension!" href="#SOLPS2ctrl.cached_mesh_extension!"><code>SOLPS2ctrl.cached_mesh_extension!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cached_mesh_extension!(
    dd::IMAS.dd,
    eqdsk_file::String,
    b2fgmtry::String;
    eq_time_idx::Int=1,
    eq_profiles_2d_idx::Int=1,
    grid_ggd_idx::Int=1,
    space_idx::Int=1,
    clear_cache::Bool=false,
)::String</code></pre><p>Adds an extended mesh to a data dictionary, possibly from a cached result.</p><p>Input Arguments:</p><ul><li><code>dd</code>: The data dictionary. It will be modified in place.</li><li><code>eqdsk_file</code>: the name of the EQDSK file that was used to get equilibrium data in the dd.</li><li><code>b2fgmtry</code>: the name of the SOLPS geometry file that was used to get GGD info in <code>edge_profiles</code> in the dd.</li><li><code>eq_time_idx</code>: Index of the time slice in equilibrium</li><li><code>eq_profiles_2d_idx</code>: Index of the 2D profile set in equilibrium (there is usually only one)</li><li><code>grid_ggd_idx</code>: Index of the <code>grid_ggd</code> set in edge_profiles</li><li><code>space_idx</code>: Index of the space</li><li><code>clear_cache</code>: delete any existing cache file (for use in testing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/supersize_profile.jl#L893-L920">source</a></section></article><h3 id="Unit-conversion-utilities"><a class="docs-heading-anchor" href="#Unit-conversion-utilities">Unit conversion utilities</a><a id="Unit-conversion-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-conversion-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.gas_unit_converter" href="#SOLPS2ctrl.gas_unit_converter"><code>SOLPS2ctrl.gas_unit_converter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gas_unit_converter(
    value_in::Float64,
    units_in::String,
    units_out::String;
    species::String=&quot;H&quot;,
    temperature::Float64=293.15,
)</code></pre><p>Converts gas flows between different units. Uses ideal gas law to convert between Pressure * volume type flows / quantities and count / current types of units. There is a version that accepts floats in and outputs floats, and another that deals in Unitful quantities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/unit_utils.jl#L28-L41">source</a></section><section><div><pre><code class="language-julia hljs">gas_unit_converter(
    value_in::Unitful.Quantity,
    units_in::String,
    units_out::String;
    species::String=&quot;H&quot;,
    temperature=293.15 * Unitful.K,
)</code></pre><p>Converts gas flows between different units. Uses ideal gas law to convert between Pressure * volume type flows / quantities and count / current types of units. This is the Unitful version.</p><p>Output will be unitful, but the units are not simplified automatically. You can perform operations such as</p><ul><li><code>(output |&gt; Unitful.upreferred).val</code></li><li><code>Unitful.uconvert(Unitful.whatever, output).val</code></li></ul><p>to handle simplification or conversion of units.</p><p>Although this function pretends torr L s<span>$^{-1}$</span> and Pa m<span>$^3$</span> s<span>$^{-1}$</span> are different, use of Unitful should cause them to behave the same way as long as you simplify or convert units at the end. This means that you can use other pressure*volume type gas units and call them torr L s<span>$^{-1}$</span> and the script will deal with them up to having messy units in the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/unit_utils.jl#L85-L111">source</a></section></article><h2 id="Control-related-functionality"><a class="docs-heading-anchor" href="#Control-related-functionality">Control related functionality</a><a id="Control-related-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Control-related-functionality" title="Permalink"></a></h2><p>This package provides a platform to perform closed loop simulations of controllers with plant models and actuator models. The key function to run these simulations is <code>run_closed_loop_sim()</code> described below. The common architecture for this platform is to create <code>mutable struct</code> for each of the actuator, plant, and controller which are subtypes of provided abstract types <code>Actuator</code>, <code>Plant</code>, and <code>Controller</code> and the struct itself is callable and performs the required function for a discrete time instance. See test examples to get an idea of how to use this feature.</p><h3 id="Plant"><a class="docs-heading-anchor" href="#Plant">Plant</a><a id="Plant-1"></a><a class="docs-heading-anchor-permalink" href="#Plant" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.Plant" href="#SOLPS2ctrl.Plant"><code>SOLPS2ctrl.Plant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Plant</code></pre><p>Abstract parent type for all plants. Whenever a user defined plant is created, it must be subtype of <code>Plant</code>.</p><p>To create a new plant with custom feautres, it must be defined as a mutable stucture which is daughter of <code>Plant</code> that contains all settings and state information for the plant and the instance itself should be callable to take as input a <code>Vector{Float64}</code> and should return an output of <code>Vector{Float64}</code>.</p><pre><code class="language-julia hljs">mutable struct CustomPlant &lt;: Plant
    settings
    state
    # ... Anything more
end

function (cp::CustomPlant)(inp::Vector{Float64})::Vector{Float64}
    # perform the plant single step forward calcualtion with inp
    # update cp.state if required
    return output
end</code></pre><p><strong>NOTE:</strong> If you need to add a linear system in your plant model, add a <a href="#SOLPS2ctrl.LinearPlant"><code>LinearPlant</code></a> instance in the attributes of your <code>CustomPlant</code> and just call the LinearPlant inside your function call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/plant.jl#L8-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.LinearPlant" href="#SOLPS2ctrl.LinearPlant"><code>SOLPS2ctrl.LinearPlant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearPlant</code></pre><p>Implementation of linear system with option of scaling and offseting inputs and outputs. It stores the system in <code>sys</code> and state of the system in <code>x</code>. Constructor:</p><pre><code class="nohighlight hljs">LinearPlant(
    sys::Union{PredictionStateSpace, StateSpace},
    x=zeros(Float64, size(sys.A, 1));
    inp_offset::Float64=0.0, inp_factor::Float64=1.0,
    out_offset::Float64=0.0, out_factor::Float64=1.0,
)</code></pre><p>Creates a LinearPlant instance with state space system <code>sys</code> and state vector <code>x</code>. It also defined input offsetting and scaling with  <code>inp_offset</code> and <code>inp_factor</code>, and similarly output unscaling and unoffseting with <code>out_offset</code> and <code>out_factor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/plant.jl#L39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.InputConditioning" href="#SOLPS2ctrl.InputConditioning"><code>SOLPS2ctrl.InputConditioning</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InputConditioning</code></pre><p>Abstract parent type for creating input conditioning to plants. Whenever a user defined input coniditioning is created it must be subtype of <code>InputConditioning</code>.</p><p>To create a new input conditioning with custom feautres, it must be defined as a mutable stucture which is daughter of <code>InputConditioning</code> that contains all settings and state information for the function and the instance itself should be callable to take as input a <code>Vector{Float64}</code> and kwargs for any parameters used and should return an output of <code>Vector{Float64}</code> which is same size as the input.</p><pre><code class="language-julia hljs">mutable struct CustomInpCond &lt;: InputConditioning
    settings
    state
    # ... Anything more
end

function (inp_cond::CustomInpCond)(inp::Vector{Float64}; kwargs...)::Vector{Float64}
    # perform the input coniditioning single step forward calcualtion with inp
    # Use parameters from kwargs
    # update inp_cond.state if required
    return output
end</code></pre><p>Note that <code>inp_cond</code> must have a call signature of <code>inp_cond(inp::Vector{Float64}; kwargs...)::Vector{Float64}</code> to take input as a vector for multiple inputs at a particular time instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/plant.jl#L80-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.InpCondLinPlant" href="#SOLPS2ctrl.InpCondLinPlant"><code>SOLPS2ctrl.InpCondLinPlant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InpCondLinPlant</code></pre><p>Implementation of a LinearPlant with an added input conditioning which could be used to make it non-linear. It stores the LinearPlant in <code>linear_plant</code>, the input coniditioning function in <code>inp_cond</code> and any keyword arguments for the <code>inp_cond</code> in <code>inp_cond_kwargs</code>. Constructor:</p><pre><code class="nohighlight hljs">InpCondLinPlant{T}(
    linear_plant::LinearPlant,
    inp_cond::InputConditioning
    inp_cond_kwargs::Dict{Symbol, T}
) where {T}</code></pre><p>Creates a InpCondLinPlant instance. <code>inp_cond_kwargs</code> can be used to have changeable parameters in the input conditioning which can be used for optimization and fiting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/plant.jl#L113-L130">source</a></section></article><h3 id="System-identification-and-modeling"><a class="docs-heading-anchor" href="#System-identification-and-modeling">System identification and modeling</a><a id="System-identification-and-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#System-identification-and-modeling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.system_id" href="#SOLPS2ctrl.system_id"><code>SOLPS2ctrl.system_id</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">system_id(
    inp::Union{Vector{Float64}, Matrix{Float64}},
    out::Union{Vector{Float64}, Matrix{Float64}},
    tt::Vector{Float64},
    order::Int;
    inp_offset::Float64=0.0, inp_factor::Float64=1.0,
    out_offset::Float64=0.0, out_factor::Float64=1.0,
    inp_cond::Union{Nothing, InputConditioning}=nothing,
    inp_cond_kwargs::Dict{Symbol, T}=Dict{Symbol, Any}(),
    newpem_kwargs::Dict{Symbol, U}=Dict{Symbol, Any}(),
    verbose::Bool=false,
) where {T, U}</code></pre><p>Perform system identification for a set on input data <code>inp</code>, output data <code>out</code>, and time series vector <code>tt</code>. If there are more than one inputs or outputs, provide them as Matrix with first dimension for ports (input or output) and second dimension for time.</p><p>If <code>inp_cond</code> is provided, it is applied before offsetting and scaling for performing system identification with keywords for this function provided in <code>inp_cond_kwargs</code>.</p><p>This function uses <a href="https://baggepinnen.github.io/ControlSystemIdentification.jl/stable/ss/#ControlSystemIdentification.newpem">ControlSystemIdentification.newpem</a> to perform the system identification. Any additional keywords for this function should be passed as dictionary in <code>newpem_kwargs</code>. For advanced use, it is recommended to do system identification directly with <code>newpem</code> instead of using this function.</p><p>Returns a linear state space model of the <code>order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/system_id.jl#L8-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.system_id_optimal_inp_cond" href="#SOLPS2ctrl.system_id_optimal_inp_cond"><code>SOLPS2ctrl.system_id_optimal_inp_cond</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">system_id_optimal_inp_cond(
    inp::Union{Vector{Float64}, Matrix{Float64}},
    out::Union{Vector{Float64}, Matrix{Float64}},
    tt::Vector{Float64},
    order::Int,
    inp_cond::InputConditioning,
    inp_cond_args_guess::Dict{Symbol, T};
    inp_offset::Float64=0.0, inp_factor::Float64=1.0,
    out_offset::Float64=0.0, out_factor::Float64=1.0,
    inp_cond_args_lower::Dict{Symbol, V}=Dict{Symbol, Any}(),
    inp_cond_args_upper::Dict{Symbol, W}=Dict{Symbol, Any}(),
    newpem_kwargs::Dict{Symbol, U}=Dict{Symbol, Any}(),
    curve_fit_kwargs::Dict{Symbol, X}=Dict{Symbol, Any}(),
    verbose::Bool=false,
) where {T, U, V, W}</code></pre><p>Perform system identification for a set on input data <code>inp</code>, output data <code>out</code>, and time series vector <code>tt</code>. If there are more than one inputs or outputs, provide them as Matrix with first dimension for ports (input or output) and second dimension for time.</p><p>The <code>inp_cond</code> is applied before offsetting and scaling for performing system identification. The <code>inp_cond_args_guess</code> is used as initial keyword arguments that provide the parameters of the <code>inp_cond</code>. These arguments are then used to find the best fit while iteratively performing <a href="#SOLPS2ctrl.system_id"><code>system_id</code></a> in each step.</p><p>This function uses <a href="https://baggepinnen.github.io/ControlSystemIdentification.jl/stable/ss/#ControlSystemIdentification.newpem">ControlSystemIdentification.newpem</a> to perform the system identification. Any additional keywords for this function should be passed as dictionary in <code>newpem_kwargs</code>.</p><p>This function uses <a href="https://julianlsolvers.github.io/LsqFit.jl/latest/api/#LsqFit.curve_fit">LsqFit.curve_fit</a> to fit the parameters of input conditions along with performing the system identification.</p><p>For advanced use, it is recommended to do system identification directly with <code>newpem</code> and optimize using your favorite fitting method instead of using this function.</p><p>Returns a NonLinInpLinearPlant that has stored best fit parameters for the input non-linearity and a best fit linear model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/system_id.jl#L150-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.model_evolve" href="#SOLPS2ctrl.model_evolve"><code>SOLPS2ctrl.model_evolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">model_evolve(
    plant::Plant,
    inp::Union{Vector{Float64}, Matrix{Float64}};
    x0::Union{Nothing, Vector{Float64}}=nothing,
    initialize_x::Bool=false,
)</code></pre><p>Evolve a plant model through a time series of inputs. If <code>inp</code> is a Matrix, the first dimension will hold different inputs and second dimension will be along time. If <code>inp</code> is a vector, it would be assumed that the model has a single input. If the model also happens to have a single output and <code>inp</code> is a vector, the returned outputs will be a vector as well. If <code>x0</code> is not provided, the stored state vector of the plant model will be used for initialization. If <code>initialize_x</code> is true, then the state vector of the plant model would be initialized to match first input value so that no sudden jumps happen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/system_id.jl#L96-L112">source</a></section></article><h3 id="Actuators"><a class="docs-heading-anchor" href="#Actuators">Actuators</a><a id="Actuators-1"></a><a class="docs-heading-anchor-permalink" href="#Actuators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.Actuator" href="#SOLPS2ctrl.Actuator"><code>SOLPS2ctrl.Actuator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Actuator</code></pre><p>Abstract parent type for all actuators. Whenever a user defined actuator is created, it must be subtype of <code>Actuator</code>.</p><p>To create a new actuator with custom function, it must be defined as a mutable stucture which is daughter of Actuator that contains all settings and state information for the actuator and the instance itself should be callable to take as input a <code>Vector{Float64}</code> and should return an output of <code>Vector{Float64}</code>.</p><pre><code class="language-julia hljs">mutable struct CustomActuator &lt;: Actuator
    settings
    state
    # ... Anything more
end

function (ca::CustomActuator)(inp::Vector{Float64})::Vector{Float64}
    # perform the actuation calcualtions with inp
    # update ca.state if required
    return output
end</code></pre><p><strong>NOTE:</strong> If you need to add a delay in the actuator, add a <a href="#SOLPS2ctrl.DelayedActuator"><code>DelayedActuator</code></a> instance in the attributes of your <code>CustomActuator</code> and just call the DelayedActuator inside your function call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/actuators.jl#L5-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.DelayedActuator" href="#SOLPS2ctrl.DelayedActuator"><code>SOLPS2ctrl.DelayedActuator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DelayedActuator{U}</code></pre><p>Implementation of delayed actuation. It stores <code>delay::Int</code> for number of time steps of delay and <code>buffer::Queue{U}</code> which stores the delayed actuations in a queue. Constructor:</p><pre><code class="nohighlight hljs">DelayedActuator(
    delay::Int;
    default_output::T=[0.0],
) where {T}</code></pre><p>Creates a DelayedActuator{T} instance with <code>delay</code> and initializes the <code>buffer</code> pre-filled upto brim with the default_output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/actuators.jl#L36-L50">source</a></section></article><p>For example:</p><pre><code class="language-julia hljs">using SOLPS2ctrl: DelayedActuator
# Actuator with delay of 3 steps
dact = DelayedActuator(3; default_output=[0.0, 0.0])
inp_series = [ones(2) * i * 0.1 for i in 1:6]
for (i, inp) in enumerate(inp_series)
    println(&quot;Calling $(i)th time, return value is $(dact(inp))&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Calling 1th time, return value is [0.0, 0.0]
Calling 2th time, return value is [0.0, 0.0]
Calling 3th time, return value is [0.0, 0.0]
Calling 4th time, return value is [0.1, 0.1]
Calling 5th time, return value is [0.2, 0.2]
Calling 6th time, return value is [0.30000000000000004, 0.30000000000000004]</code></pre><h3 id="Controllers"><a class="docs-heading-anchor" href="#Controllers">Controllers</a><a id="Controllers-1"></a><a class="docs-heading-anchor-permalink" href="#Controllers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.Controller" href="#SOLPS2ctrl.Controller"><code>SOLPS2ctrl.Controller</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Controller</code></pre><p>Abstract parent type for all controllers. Whenever a user defined controller is created it must be a subtype of <code>Controller</code>.</p><p>To create a new controller algorithm, it should be defined as a mutable structure that is a daughter of <code>Controller</code> and should contain all settings and state information to be stored. It must be a callable structure that can use any of the following keyword arguments:</p><ul><li><code>ii::Int</code>: Iteration index</li><li><code>target::Matrix{Float64}</code>: Target waveform (No. of signals x Time steps)</li><li><code>plant_inp::Matrix{Float64}</code>: Inputs to plant (No. of inputs x Time steps)</li><li><code>plant_out::Matrix{Float64}</code>: Outputs from plant (No. of outputs x Time steps)</li><li><code>act::Actuator</code>: Actuator model in the loop</li><li><code>inp_feedforward::Matrix{Float64}</code>: Feedforward input to the plant (No. of inputs x Time steps)</li><li><code>kwargs..</code>: Required to ignore unused keyword arguments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/controllers.jl#L10-L28">source</a></section></article><h4 id="Linear-Controller"><a class="docs-heading-anchor" href="#Linear-Controller">Linear Controller</a><a id="Linear-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Controller" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.LinearController" href="#SOLPS2ctrl.LinearController"><code>SOLPS2ctrl.LinearController</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearController</code></pre><p>Implementation for using any linear controller. It stores <code>ctrl_ss::StateSpace{TE} where {TE &lt;: Discrete}</code> for storing any linear controller as a discrete state space model using <a href="https://juliacontrol.github.io/ControlSystems.jl/dev/man/creating_systems/#State-Space-Systems">ControlSystemsBase.ss</a>. It also stores the state vector for the state space model as <code>ctrl_x0::Vector{Float64}</code>. It&#39;s call signature is:</p><pre><code class="nohighlight hljs">(lc::LinearController)(;
    ii::Int,
    target::Matrix{Float64},
    plant_out::Matrix{Float64},
    kwargs...,
)::Vector{Float64}</code></pre><p>Calcualtes error as <code>target[:, ii] .- plant_out[:, ii]</code> and runs it through <a href="#SOLPS2ctrl.lsim_step"><code>lsim_step()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/controllers.jl#L31-L49">source</a></section></article><h4 id="Predicted-Variable-Linear-Controller"><a class="docs-heading-anchor" href="#Predicted-Variable-Linear-Controller">Predicted Variable Linear Controller</a><a id="Predicted-Variable-Linear-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Predicted-Variable-Linear-Controller" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.PVLC" href="#SOLPS2ctrl.PVLC"><code>SOLPS2ctrl.PVLC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PVLC

# Constructor
PVLC(
    ctrl_ss::StateSpace{TE},
    ctrl_x0::Vector{Float64},
    plant::LinearPlant,
    h::Int,
) where {TE &lt;: Discrete}</code></pre><p>Implementation of Predicted Variable Linear Controller (PVLC). It stores <code>ctrl_ss::StateSpace{TE} where {TE &lt;: Discrete}</code> for storing any linear controller as a discrete state space model using <a href="https://juliacontrol.github.io/ControlSystems.jl/dev/man/creating_systems/#State-Space-Systems">ControlSystemsBase.ss</a>. It also stores the state vector for the state space model as <code>ctrl_x0::Vector{Float64}</code>. Additionally, it stores the <code>plant</code>, the number of steps of history <code>h</code> used for state tracking and state prediction matrices <code>Y2x</code> and <code>U2x</code> from <a href="#SOLPS2ctrl.state_prediction_matrices"><code>state_prediction_matrices()</code></a>.</p><p>This controller has a call signature:</p><pre><code class="nohighlight hljs">(pvlc::PVLC)(;
    ii::Int,
    target::Matrix{Float64},
    plant_inp::Matrix{Float64},
    plant_out::Matrix{Float64},
    act::Actuator,
    kwargs...,
)::Vector{Float64}</code></pre><p>Tracks the state vector of the plant using <code>h</code> steps of history from <code>plant_inp</code> and <code>plant_out</code> and uses it to calculate future output of the plant. It compares it with a future <code>target</code> value and applies the linear controller <code>ctrl_ss</code> there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/controllers.jl#L135-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.state_prediction_matrices" href="#SOLPS2ctrl.state_prediction_matrices"><code>SOLPS2ctrl.state_prediction_matrices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">state_prediction_matrices(
    sys::Union{PredictionStateSpace, StateSpace},
    h::Int=size(sys.A, 1),
)</code></pre><p>Calculate state prediction matrices for a linear system <code>sys</code> given <code>h</code> steps of input and output history. This function returns two matrices, <code>Y2x</code> and <code>U2x</code> that can be used to calculate least square fitted estimate of the current state vector of the system. <code>Y2x</code> has size: (State size of <code>sys</code>) x (No. of outputs times h) <code>U2x</code> has size: (State size of <code>sys</code>) x (No. of inputs times h) The estimated state vector is obtained by: Y2x * Y + U2x * U where Y is all the <code>h</code> outputs of system stacked into a single vector. and U is all the <code>h</code> inputs to the system stacked into a single vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/controllers.jl#L107-L123">source</a></section></article><h5 id="State-Prediction-Matrix-Algebra"><a class="docs-heading-anchor" href="#State-Prediction-Matrix-Algebra">State Prediction Matrix Algebra</a><a id="State-Prediction-Matrix-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#State-Prediction-Matrix-Algebra" title="Permalink"></a></h5><p>At step k:</p><p class="math-container">\[\begin{split}
y_k &amp;= C x_k + D u_k\\
x_k &amp;= A x_{k-1} + B u_{k-1}\\
x_{k+1} &amp;= A x_{k} + B u_{k}
\end{split}\]</p><p>Therefore to h steps in history:</p><p>For all output estimates:</p><p class="math-container">\[\begin{split}
y_k &amp; = C x_k + D u_k \\
    &amp; = C (A x_{k-1} + B u_{k-1}) + D u_k \\
    &amp; = C (A (A x_{k-2} + B u_{k-2}) + B u_{k-1}) + D u_k \\
    &amp; = ... \\
    &amp; = C A^{h-1} x_{k-(h-1)} + C A^{h-2} B u_{k-(h-1)} + C A^{h-3} B u_{k-(h-2)} + ... + CAB u_{k-2} + CB u_{k-1} + D u_k \\
\end{split}\]</p><p class="math-container">\[\begin{split}
y_k         &amp;= C A^{h-1} x_{k-(h-1)} + C A^{h-2} B u_{k-(h-1)} + C A^{h-3} B u_{k-(h-2)} + ... + CAB u_{k-2} + CB u_{k-1} + D u_k \\
y_{k-1}     &amp;= C A^{h-2} x_{k-(h-1)} + C A^{h-3} B u_{k-(h-1)} + C A^{h-4} B u_{k-(h-2)} + ... + CAB u_{k-3} + CB u_{k-2} + D u_{k-1} \\

...         &amp;= ... \\
y_{k-i}     &amp;= C A^{h-1-i} x_{k-(h-1)} + C A^{h-2-i} B u_{k-(h-1)} + C A^{h-3-i} B u_{k-(h-2)} + ... + CB u_{k-i-1} + D u_{k-i} \\
...         &amp;= ... \\
y_{k-(h-3)} &amp;= C A^2 x_{k-(h-1)} + CAB u_{k-(h-1)}+ CB u_{k-(h-2)} + D u_{k-(h-3)} \\
y_{k-(h-2)} &amp;= C A x_{k-(h-1)} + CB u_{k-(h-1)} + D u_{k-(h-2)} \\
y_{k-(h-1)} &amp;= C x_{k-(h-1)} + D u_{k-(h-1)}
\end{split}\]</p><p>For predicted next state:</p><p class="math-container">\[\begin{split}
x_{k+1} &amp; = A x_{k} + B u_{k} \\
        &amp; = A (A x_{k-1} + B u_{k-1}) + B u_{k} \\
        &amp; = A (A (A x_{k-2} + B u_{k-2})  + B u_{k-1}) + B u_{k} \\
        &amp; = ... \\
        &amp; = A^h x_{k-(h-1)} + A^{h-1} B u_{k-(h-1)} + A^{h-2} B u_{k-(h-2)} + ... + A^2 B u_{k-2} + A B u_{k-1} + B u_{k} \\
\end{split}\]</p><p>In terms of mega-matrices, define mega-vectors of inputs and outputs:</p><p class="math-container">\[\vec{Y}  = \begin{bmatrix}
                y_{k-(h-1)} \\
                y_{k-(h-2)} \\
                ... \\
                y_{k-1} \\
                y_{k}
              \end{bmatrix}\]</p><p>Note that for multiple outputs, each output vector will be stacked vertically to create a single column.</p><p class="math-container">\[\vec{U}  = \begin{bmatrix}
                u_{k-(h-1)} \\
                u_{k-(h-2)} \\
                ... \\
                u_{k-1} \\
                u_{k}
              \end{bmatrix}\]</p><p>Note that for multiple inputs, each input vector will be stacked vertically to create a single column.</p><p>Then, from <span>$x_{k-(h-1)}$</span> and <span>$\vec{U}$</span>, we get <span>$\vec{Y}$</span> and predicted state <span>$x_{k+1}$</span>:</p><p class="math-container">\[\vec{Y} = \mathcal{L} x_{k-(h-1)} + \mathcal{M} \vec{U}\]</p><p class="math-container">\[x_{k+1} = \mathcal{N} x_{k-(h-1)} + \mathcal{O} \vec{U}\]</p><p>Where the mega-matrices <span>$\mathcal{L}$</span>, <span>$\mathcal{M}$</span>, <span>$\mathcal{N}$</span>, <span>$\mathcal{O}$</span> are:</p><p><span>$\mathcal{L}$</span> is a matrix with (h x no. of outputs) rows and state-space order columns:</p><p class="math-container">\[\mathcal{L} = \begin{bmatrix}
                  C... \\
                  CA... \\
                  CA^2... \\
                  ... \\
                  CA^{h-2}... \\
                  CA^{h-1}...
               \end{bmatrix}\]</p><p><span>$\mathcal{M}$</span> is a matrix with (h x no. of outputs) rows and (h x no. of inputs) columns:</p><p class="math-container">\[\mathcal{M} = \begin{bmatrix}
                  D           &amp; 0           &amp; 0           &amp; ... &amp; 0     &amp; 0     &amp; 0   &amp; 0   &amp;     \\
                  CB          &amp; D           &amp; 0           &amp; ... &amp; 0     &amp; 0     &amp; 0   &amp; 0   &amp;     \\
                  CAB         &amp; CB          &amp; D           &amp; ... &amp; 0     &amp; 0     &amp; 0   &amp; 0   &amp;     \\
                  ...         &amp; ...         &amp; ...         &amp; ... &amp; ...   &amp; ...   &amp; ... &amp; ... &amp; ... \\
                  C A^{h-4} B &amp; C A^{h-5} B &amp; C A^{h-6} B &amp; ... &amp; CAB   &amp; CB    &amp; D   &amp; 0   &amp; 0   \\
                  C A^{h-3} B &amp; C A^{h-4} B &amp; C A^{h-5} B &amp; ... &amp; CA^2B &amp; CAB   &amp; CB  &amp; D   &amp; 0   \\
                  C A^{h-2} B &amp; C A^{h-3} B &amp; C A^{h-4} B &amp; ... &amp; CA^3B &amp; CA^2B &amp; CAB &amp; CB  &amp; D   \\
                 \end{bmatrix}\]</p><p><span>$\mathcal{N}$</span> is a square matrix with state-space order columns and rows:</p><p class="math-container">\[\mathcal{N} = A^{h}\]</p><p><span>$\mathcal{O}$</span> is a matrix with state-space order rows and (h x no. of inputs) columns:</p><p class="math-container">\[\mathcal{O} = \begin{bmatrix} A^{h-1} B &amp; A^{h-2} B &amp; A^{h-3} B &amp; ... &amp; A^2 B &amp; AB &amp; B \end{bmatrix}\]</p><p>Then, future state can be predicted by:</p><p class="math-container">\[x_{k+1} = \mathcal{N} \mathcal{L}^{-1} (\vec{Y} - \mathcal{M} \vec{U}) + \mathcal{O} \vec{U}\]</p><h4 id="Model-Predictive-Controller"><a class="docs-heading-anchor" href="#Model-Predictive-Controller">Model Predictive Controller</a><a id="Model-Predictive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Predictive-Controller" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.MPC" href="#SOLPS2ctrl.MPC"><code>SOLPS2ctrl.MPC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPC

# Constructor
MPC(
    plant::Plant,
    h::Int,
    act::Actuator,               # Actuator model without delay
    horizon::Int,                # Number of steps in future after latency
    nopt::Int,                   # Number of optimization points in horizon window
    opt_every::Int;              # Run cost optimization every opt_every steps
    ctrl_out_bounds::Tuple{Vector{Float64}, Vector{Float64}}=(
        Array{Float64}(undef, 0),
        Array{Float64}(undef, 0),
    ),
    guess::Union{Symbol, Vector{Float64}}=:zeros,
    curve_fit_kwargs::Dict{Symbol, T}=Dict{Symbol, Any}(),
)</code></pre><p>Implementation of simple leaqt square optimized Model Predictive Controller (MPC). It stores the <code>plant</code>, the number of steps of history <code>h</code> used for state tracking and state prediction matrices <code>Y2x</code> and <code>U2x</code> from <a href="#SOLPS2ctrl.state_prediction_matrices"><code>state_prediction_matrices()</code></a>. It stores a current deep copy of actuator instance  in <code>act</code> to try it during optimization and it stores setting for least square optimization. It also stores a <code>future_evolve</code> that is created based on <code>plant</code>, <code>act</code>, and optimization setting and is the model function that is used for optimization later. This controller stores a buffer for control outputs, <code>ctrl_out_buffer</code> so that it can be called less often and it can reuse it&#39;s previous optimization results.</p><p>This contructor takes in minimum required information to create a self-consistent MPC instance. It sets the other dependent quantities in MPC such as <code>Y2x</code>, <code>U2x</code>, <code>min_delay</code>, and create a <code>future_evolve</code> function and initializes the <code>ctrl_out_buffer</code>. <code>act</code> needs to be a deepcopy of the actuator instance. <code>horizon</code> is the number of steps after the <code>min_delay</code> among all acturators for which the optimization is carried out. <code>nopt</code> is the number of optimization points taken along the <code>horizon</code> which are lineary distributed. The gaps between this optimzation points are interpolated linearly in the output. <code>opt_every</code> defines the frequency of optimization, i.e. at every <code>opt_every</code> call of this controller, the optimization is carried out. This avoids unnecessary over-calculations and thus results in a faster controller. <code>ctrl_out_bounds</code> is a tuple of lower bounds and upper bounds for the control output. <code>guess</code> is used to create the initial guess during least square optimization. If <code>:last</code>, it would use the last controller output as initial setting. If it is a <code>Vector</code>, each initialization starts with this Vector. In all other cases, initial guess is zeros. <code>curve_fit_kwargs</code> can be used to provide keyword arguments that go to <code>curve_fit</code>.</p><p>This controller has a call signature:</p><pre><code class="nohighlight hljs">function (mpc::MPC)(;
    ii::Int,
    target::Matrix{Float64},
    plant_inp::Matrix{Float64},
    plant_out::Matrix{Float64},
    act::Actuator,
    inp_feedforward::Matrix{Float64}=zeros(
        Float64,
        (size(get_sys(plant).B, 2), length(target)),
    ),
    kwargs...,
)::Vector{Float64} where {T}</code></pre><p>Tracks the state vector of the plant using <code>h</code> steps of history from <code>plant_inp</code> and <code>plant_out</code> and uses it along with <code>act</code> to run an optimization to match <code>target</code> in future after the minimum delay from all the actuators. This function uses <a href="https://julianlsolvers.github.io/LsqFit.jl/latest/api/#LsqFit.curve_fit"><code>curve_fit()</code></a> for the non-linear least squares fitting which uses Levenberg-Marquardt algorithm. This function performs the optimization every <code>opt_every</code> call and uses the stored control output in <code>ctrl_out_buffer</code> meanwhile.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/controllers.jl#L243-L310">source</a></section></article><h3 id="Closed-loop-simulations"><a class="docs-heading-anchor" href="#Closed-loop-simulations">Closed loop simulations</a><a id="Closed-loop-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-loop-simulations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.run_closed_loop_sim" href="#SOLPS2ctrl.run_closed_loop_sim"><code>SOLPS2ctrl.run_closed_loop_sim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_closed_loop_sim(
    plant::Union{PredictionStateSpace{TE}, StateSpace{TE}},
    act::Actuator,
    ctrl::Controller,
    target::Matrix{Float64};
    inp_feedforward::Matrix{Float64}=zeros(
        Float64,
        (size(get_sys(plant).B, 2), size(target, 2)),
    ),
    ctrl_start_ind::Int=1,
    noise_plant_inp::Matrix{Float64}=zeros(
        Float64,
        (size(get_sys(plant).B, 2), size(target, 2)),
    ),
    noise_plant_out::Matrix{Float64}=zeros(
        Float64,
        (size(get_sys(plant).C, 1), size(target, 2)),
    ),
    noise_ctrl_out::Matrix{Float64}=zeros(
        Float64,
        (size(get_sys(plant).B, 2), size(target, 2)),
    ),
) where {T, TE &lt;: Discrete}</code></pre><p>Generic function to run closed loop simulations with provided <code>plant</code>, actuator <code>act</code>, controller <code>ctrl</code>, and target waveform <code>target</code>. The length of simulation is determined by provided <code>target</code>. Keyword arguments are possible for providing adjustments to inputs and outputs of the plant model as explained in <a href="#SOLPS2ctrl.model_evolve"><code>model_evolve()</code></a>. Additionally, <code>ctrl_start_ind</code> can be provided to start control loop at an arbitrary point in the loop. <code>noise_plant_inp</code>, <code>noise_plant_out</code>, and <code>noise_ctrl_out</code> allow addition of predefined noise waveforms at the input of plant, output of plant, and the output of controller respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/controllers.jl#L453-L486">source</a></section></article><h3 id="Control-related-utilities"><a class="docs-heading-anchor" href="#Control-related-utilities">Control related utilities</a><a id="Control-related-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Control-related-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.lsim_step" href="#SOLPS2ctrl.lsim_step"><code>SOLPS2ctrl.lsim_step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lsim_step(
    sys::Union{PredictionStateSpace, StateSpace}, u::Vector{Float64};
    x0::Vector{Float64}=zeros(size(sys.A, 1)),
)::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Single step version of <a href="https://juliacontrol.github.io/ControlSystems.jl/dev/lib/timefreqresponse/#ControlSystemsBase.lsim-Tuple%7BAbstractStateSpace,%20AbstractVecOrMat,%20AbstractVector%7D">ControlSystemsBase.lsim</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/control_utils.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.offset_scale" href="#SOLPS2ctrl.offset_scale"><code>SOLPS2ctrl.offset_scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">offset_scale(
    val::Union{Float64, Vector{Float64}, Matrix{Float64}};
    offset::Union{Float64, Vector{Float64}}=0.0,
    factor::Union{Float64, Vector{Float64}}=1.0,
)::typeof(val)</code></pre><p>Subtract an <code>offset</code> and multiply by a <code>factor</code>, the <code>val</code> to make it nominally in the range of -1 to 1 (not strictly) for easy identification of system.</p><pre><code class="nohighlight hljs">(val .- offset) .* factor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/control_utils.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SOLPS2ctrl.unscale_unoffset" href="#SOLPS2ctrl.unscale_unoffset"><code>SOLPS2ctrl.unscale_unoffset</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unscale_unoffset(
    offset_scaled::Union{Float64, Vector{Float64}, Matrix{Float64}};
    offset::Union{Float64, Vector{Float64}}=0.0,
    factor::Union{Float64, Vector{Float64}}=1.0,
)::typeof(offset_scaled)</code></pre><p>Undo previously applied offset and scaling.</p><pre><code class="nohighlight hljs">offset_scaled ./ factor .+ offset</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ProjectTorreyPines/SOLPS2ctrl.jl/blob/d67029b6aba3d5cd8449c7c2c5107a2ab7409339/src/control_utils.jl#L43-L53">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 00:06">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
